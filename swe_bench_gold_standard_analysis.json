{
  "summary": {
    "total_instances": 5,
    "instances_with_gold_patch": 5,
    "average_contexts_per_instance": 29.0,
    "average_files_per_instance": 5.4,
    "gold_patch_coverage": {
      "average_file_coverage": 0.8,
      "average_code_block_coverage": 0.8,
      "average_function_coverage": 0.0,
      "average_class_coverage": 0.0,
      "perfect_file_coverage_count": 4,
      "perfect_block_coverage_count": 4,
      "perfect_function_coverage_count": 0,
      "perfect_class_coverage_count": 0
    },
    "test_results": {
      "successful_tests": 0,
      "resolved_issues": 0,
      "test_success_rate": 0.0,
      "issue_resolution_rate": 0.0
    }
  },
  "by_project": {
    "scikit-learn": {
      "instances": 1,
      "avg_file_coverage": 1.0,
      "avg_function_coverage": 0.0,
      "avg_class_coverage": 0.0,
      "test_success_rate": 0.0,
      "issue_resolution_rate": 0.0
    },
    "django": {
      "instances": 2,
      "avg_file_coverage": 1.0,
      "avg_function_coverage": 0.0,
      "avg_class_coverage": 0.0,
      "test_success_rate": 0.0,
      "issue_resolution_rate": 0.0
    },
    "pytest-dev": {
      "instances": 1,
      "avg_file_coverage": 0.0,
      "avg_function_coverage": 0.0,
      "avg_class_coverage": 0.0,
      "test_success_rate": 0.0,
      "issue_resolution_rate": 0.0
    },
    "sympy": {
      "instances": 1,
      "avg_file_coverage": 1.0,
      "avg_function_coverage": 0.0,
      "avg_class_coverage": 0.0,
      "test_success_rate": 0.0,
      "issue_resolution_rate": 0.0
    }
  },
  "detailed_instances": [
    {
      "instance_id": "scikit-learn__scikit-learn-13142",
      "project": "scikit-learn",
      "total_contexts_found": 24,
      "unique_files_accessed": 3,
      "contexts_detail": [
        {
          "file_path": "sklearn/mixture/tests/test_gaussian_mixture.py",
          "start_line": 580,
          "end_line": 598,
          "content": "def test_gaussian_mixture_fit_predict(seed, max_iter, tol):\\n    rng = np.random.RandomState(seed)\\n    rand_data = RandomData(rng)\\n    for covar_type in COVARIANCE_TYPE:\\n        X = rand_data.X[covar_type]\\n        Y = rand_data.Y\\n        g = GaussianMixture(n_components=rand_data.n_components,\\n                            random_state=rng, weights_init=rand_data.weights,\\n                            means_init=rand_data.means,\\n                            precisions_init=rand_data.precisions[covar_type],\\n                            covariance_type=covar_type,\\n                            max_iter=max_iter, tol=tol)\\n\\n        # check if fit_predict(X) is equivalent to fit(X).predict(X)\\n        f = copy.deepcopy(g)\\n        Y_pred1 = f.fit(X).predict(X)\\n        Y_pred2 = g.fit_predict(X)\\n        assert_array_equal(Y_pred1, Y_pred2)\\n        assert_greater(adjusted_rand_score(Y, Y_pred2), .95)\\n",
          "lines_count": 19
        },
        {
          "file_path": "sklearn/mixture/tests/test_gaussian_mixture.py",
          "start_line": 688,
          "end_line": 700,
          "content": "def test_multiple_init():\\n    # Test that multiple inits does not much worse than a single one\\n    rng = np.random.RandomState(0)\\n    n_samples, n_features, n_components = 50, 5, 2\\n    X = rng.randn(n_samples, n_features)\\n    for cv_type in COVARIANCE_TYPE:\\n        train1 = GaussianMixture(n_components=n_components,\\n                                 covariance_type=cv_type,\\n                                 random_state=0).fit(X).score(X)\\n        train2 = GaussianMixture(n_components=n_components,\\n                                 covariance_type=cv_type,\\n                                 random_state=0, n_init=5).fit(X).score(X)\\n        assert_greater_equal(train2, train1)\\n",
          "lines_count": 13
        },
        {
          "file_path": "sklearn/mixture/tests/test_gaussian_mixture.py",
          "start_line": 548,
          "end_line": 570,
          "content": "def test_gaussian_mixture_predict_predict_proba():\\n    rng = np.random.RandomState(0)\\n    rand_data = RandomData(rng)\\n    for covar_type in COVARIANCE_TYPE:\\n        X = rand_data.X[covar_type]\\n        Y = rand_data.Y\\n        g = GaussianMixture(n_components=rand_data.n_components,\\n                            random_state=rng, weights_init=rand_data.weights,\\n                            means_init=rand_data.means,\\n                            precisions_init=rand_data.precisions[covar_type],\\n                            covariance_type=covar_type)\\n\\n        # Check a warning message arrive if we don\\",
          "lines_count": 23
        },
        {
          "file_path": "sklearn/mixture/tests/test_gaussian_mixture.py",
          "start_line": 580,
          "end_line": 598,
          "content": "def test_gaussian_mixture_fit_predict(seed, max_iter, tol):\\n    rng = np.random.RandomState(seed)\\n    rand_data = RandomData(rng)\\n    for covar_type in COVARIANCE_TYPE:\\n        X = rand_data.X[covar_type]\\n        Y = rand_data.Y\\n        g = GaussianMixture(n_components=rand_data.n_components,\\n                            random_state=rng, weights_init=rand_data.weights,\\n                            means_init=rand_data.means,\\n                            precisions_init=rand_data.precisions[covar_type],\\n                            covariance_type=covar_type,\\n                            max_iter=max_iter, tol=tol)\\n\\n        # check if fit_predict(X) is equivalent to fit(X).predict(X)\\n        f = copy.deepcopy(g)\\n        Y_pred1 = f.fit(X).predict(X)\\n        Y_pred2 = g.fit_predict(X)\\n        assert_array_equal(Y_pred1, Y_pred2)\\n        assert_greater(adjusted_rand_score(Y, Y_pred2), .95)\\n",
          "lines_count": 19
        },
        {
          "file_path": "sklearn/mixture/tests/test_gaussian_mixture.py",
          "start_line": 688,
          "end_line": 700,
          "content": "def test_multiple_init():\\n    # Test that multiple inits does not much worse than a single one\\n    rng = np.random.RandomState(0)\\n    n_samples, n_features, n_components = 50, 5, 2\\n    X = rng.randn(n_samples, n_features)\\n    for cv_type in COVARIANCE_TYPE:\\n        train1 = GaussianMixture(n_components=n_components,\\n                                 covariance_type=cv_type,\\n                                 random_state=0).fit(X).score(X)\\n        train2 = GaussianMixture(n_components=n_components,\\n                                 covariance_type=cv_type,\\n                                 random_state=0, n_init=5).fit(X).score(X)\\n        assert_greater_equal(train2, train1)\\n",
          "lines_count": 13
        },
        {
          "file_path": "sklearn/mixture/tests/test_gaussian_mixture.py",
          "start_line": 548,
          "end_line": 570,
          "content": "def test_gaussian_mixture_predict_predict_proba():\\n    rng = np.random.RandomState(0)\\n    rand_data = RandomData(rng)\\n    for covar_type in COVARIANCE_TYPE:\\n        X = rand_data.X[covar_type]\\n        Y = rand_data.Y\\n        g = GaussianMixture(n_components=rand_data.n_components,\\n                            random_state=rng, weights_init=rand_data.weights,\\n                            means_init=rand_data.means,\\n                            precisions_init=rand_data.precisions[covar_type],\\n                            covariance_type=covar_type)\\n\\n        # Check a warning message arrive if we don\\",
          "lines_count": 23
        },
        {
          "file_path": "sklearn/mixture/gaussian_mixture.py",
          "start_line": 434,
          "end_line": 755,
          "content": "class GaussianMixture(BaseMixture):\\n    \"\"\"Gaussian Mixture.\\n\\n    Representation of a Gaussian mixture model probability distribution.\\n    This class allows to estimate the parameters of a Gaussian mixture\\n    distribution.\\n\\n    Read more in the :ref:`User Guide <gmm>`.\\n\\n    .. versionadded:: 0.18\\n\\n    Parameters\\n    ----------\\n    n_components : int, defaults to 1.\\n        The number of mixture components.\\n\\n    covariance_type : {\\",
          "lines_count": 322
        },
        {
          "file_path": "sklearn/mixture/base.py",
          "start_line": 64,
          "end_line": 374,
          "content": "class BaseMixture(DensityMixin, BaseEstimator, metaclass=ABCMeta):\\n    \"\"\"Base class for mixture models.\\n\\n    This abstract class specifies an interface for all mixture classes and\\n    provides basic common methods for mixture models.\\n    \"\"\"\\n\\n    def __init__(self, n_components, tol, reg_covar,\\n                 max_iter, n_init, init_params, random_state, warm_start,\\n                 verbose, verbose_interval):\\n        self.n_components = n_components\\n        self.tol = tol\\n        self.reg_covar = reg_covar\\n        self.max_iter = max_iter\\n        self.n_init = n_init\\n        self.init_params = init_params\\n        self.random_state = random_state\\n        self.warm_start = warm_start\\n        self.verbose = verbose\\n        self.verbose_interval = verbose_interval\\n\\n    def _check_initial_parameters(self, X):\\n        \"\"\"Check values of the basic parameters.\\n\\n        Parameters\\n        ----------\\n        X : array-like, shape (n_samples, n_features)\\n        \"\"\"\\n        if self.n_components < 1:\\n            raise ValueError(\"Invalid value for \\",
          "lines_count": 311
        },
        {
          "file_path": "sklearn/mixture/gaussian_mixture.py",
          "start_line": 434,
          "end_line": 755,
          "content": "class GaussianMixture(BaseMixture):\\n    \"\"\"Gaussian Mixture.\\n\\n    Representation of a Gaussian mixture model probability distribution.\\n    This class allows to estimate the parameters of a Gaussian mixture\\n    distribution.\\n\\n    Read more in the :ref:`User Guide <gmm>`.\\n\\n    .. versionadded:: 0.18\\n\\n    Parameters\\n    ----------\\n    n_components : int, defaults to 1.\\n        The number of mixture components.\\n\\n    covariance_type : {\\",
          "lines_count": 322
        },
        {
          "file_path": "sklearn/mixture/base.py",
          "start_line": 64,
          "end_line": 374,
          "content": "class BaseMixture(DensityMixin, BaseEstimator, metaclass=ABCMeta):\\n    \"\"\"Base class for mixture models.\\n\\n    This abstract class specifies an interface for all mixture classes and\\n    provides basic common methods for mixture models.\\n    \"\"\"\\n\\n    def __init__(self, n_components, tol, reg_covar,\\n                 max_iter, n_init, init_params, random_state, warm_start,\\n                 verbose, verbose_interval):\\n        self.n_components = n_components\\n        self.tol = tol\\n        self.reg_covar = reg_covar\\n        self.max_iter = max_iter\\n        self.n_init = n_init\\n        self.init_params = init_params\\n        self.random_state = random_state\\n        self.warm_start = warm_start\\n        self.verbose = verbose\\n        self.verbose_interval = verbose_interval\\n\\n    def _check_initial_parameters(self, X):\\n        \"\"\"Check values of the basic parameters.\\n\\n        Parameters\\n        ----------\\n        X : array-like, shape (n_samples, n_features)\\n        \"\"\"\\n        if self.n_components < 1:\\n            raise ValueError(\"Invalid value for \\",
          "lines_count": 311
        },
        {
          "file_path": "sklearn/mixture/base.py",
          "start_line": 194,
          "end_line": 276,
          "content": "    def fit_predict(self, X, y=None):\\n        \"\"\"Estimate model parameters using X and predict the labels for X.\\n\\n        The method fits the model n_init times and sets the parameters with\\n        which the model has the largest likelihood or lower bound. Within each\\n        trial, the method iterates between E-step and M-step for `max_iter`\\n        times until the change of likelihood or lower bound is less than\\n        `tol`, otherwise, a `ConvergenceWarning` is raised. After fitting, it\\n        predicts the most probable label for the input data points.\\n\\n        .. versionadded:: 0.20\\n\\n        Parameters\\n        ----------\\n        X : array-like, shape (n_samples, n_features)\\n            List of n_features-dimensional data points. Each row\\n            corresponds to a single data point.\\n\\n        Returns\\n        -------\\n        labels : array, shape (n_samples,)\\n            Component labels.\\n        \"\"\"\\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\\n        self._check_initial_parameters(X)\\n\\n        # if we enable warm_start, we will have a unique initialisation\\n        do_init = not(self.warm_start and hasattr(self, \\",
          "lines_count": 83
        },
        {
          "file_path": "sklearn/mixture/base.py",
          "start_line": 358,
          "end_line": 374,
          "content": "    def predict(self, X):\\n        \"\"\"Predict the labels for the data samples in X using trained model.\\n\\n        Parameters\\n        ----------\\n        X : array-like, shape (n_samples, n_features)\\n            List of n_features-dimensional data points. Each row\\n            corresponds to a single data point.\\n\\n        Returns\\n        -------\\n        labels : array, shape (n_samples,)\\n            Component labels.\\n        \"\"\"\\n        self._check_is_fitted()\\n        X = _check_X(X, None, self.means_.shape[1])\\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\\n",
          "lines_count": 17
        },
        {
          "file_path": "sklearn/mixture/base.py",
          "start_line": 131,
          "end_line": 155,
          "content": "    def _initialize_parameters(self, X, random_state):\\n        \"\"\"Initialize the model parameters.\\n\\n        Parameters\\n        ----------\\n        X : array-like, shape  (n_samples, n_features)\\n\\n        random_state : RandomState\\n            A random number generator instance.\\n        \"\"\"\\n        n_samples, _ = X.shape\\n\\n        if self.init_params == \\",
          "lines_count": 25
        },
        {
          "file_path": "sklearn/mixture/gaussian_mixture.py",
          "start_line": 272,
          "end_line": 274,
          "content": "        self._set_parameters(best_params)\\n        self.n_iter_ = best_n_iter\\n        self.lower_bound_ = max_lower_bound\\n",
          "lines_count": 3
        },
        {
          "file_path": "sklearn/mixture/base.py",
          "start_line": 194,
          "end_line": 276,
          "content": "    def fit_predict(self, X, y=None):\\n        \"\"\"Estimate model parameters using X and predict the labels for X.\\n\\n        The method fits the model n_init times and sets the parameters with\\n        which the model has the largest likelihood or lower bound. Within each\\n        trial, the method iterates between E-step and M-step for `max_iter`\\n        times until the change of likelihood or lower bound is less than\\n        `tol`, otherwise, a `ConvergenceWarning` is raised. After fitting, it\\n        predicts the most probable label for the input data points.\\n\\n        .. versionadded:: 0.20\\n\\n        Parameters\\n        ----------\\n        X : array-like, shape (n_samples, n_features)\\n            List of n_features-dimensional data points. Each row\\n            corresponds to a single data point.\\n\\n        Returns\\n        -------\\n        labels : array, shape (n_samples,)\\n            Component labels.\\n        \"\"\"\\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\\n        self._check_initial_parameters(X)\\n\\n        # if we enable warm_start, we will have a unique initialisation\\n        do_init = not(self.warm_start and hasattr(self, \\",
          "lines_count": 83
        },
        {
          "file_path": "sklearn/mixture/base.py",
          "start_line": 358,
          "end_line": 374,
          "content": "    def predict(self, X):\\n        \"\"\"Predict the labels for the data samples in X using trained model.\\n\\n        Parameters\\n        ----------\\n        X : array-like, shape (n_samples, n_features)\\n            List of n_features-dimensional data points. Each row\\n            corresponds to a single data point.\\n\\n        Returns\\n        -------\\n        labels : array, shape (n_samples,)\\n            Component labels.\\n        \"\"\"\\n        self._check_is_fitted()\\n        X = _check_X(X, None, self.means_.shape[1])\\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\\n",
          "lines_count": 17
        },
        {
          "file_path": "sklearn/mixture/base.py",
          "start_line": 131,
          "end_line": 155,
          "content": "    def _initialize_parameters(self, X, random_state):\\n        \"\"\"Initialize the model parameters.\\n\\n        Parameters\\n        ----------\\n        X : array-like, shape  (n_samples, n_features)\\n\\n        random_state : RandomState\\n            A random number generator instance.\\n        \"\"\"\\n        n_samples, _ = X.shape\\n\\n        if self.init_params == \\",
          "lines_count": 25
        },
        {
          "file_path": "sklearn/mixture/gaussian_mixture.py",
          "start_line": 272,
          "end_line": 274,
          "content": "        self._set_parameters(best_params)\\n        self.n_iter_ = best_n_iter\\n        self.lower_bound_ = max_lower_bound\\n",
          "lines_count": 3
        },
        {
          "file_path": "sklearn/mixture/gaussian_mixture.py",
          "start_line": 660,
          "end_line": 687,
          "content": "    def _m_step(self, X, log_resp):\\n        \"\"\"M step.\\n\\n        Parameters\\n        ----------\\n        X : array-like, shape (n_samples, n_features)\\n\\n        log_resp : array-like, shape (n_samples, n_components)\\n            Logarithm of the posterior probabilities (or responsibilities) of\\n            the point of each sample in X.\\n        \"\"\"\\n        n_samples, _ = X.shape\\n        self.weights_, self.means_, self.covariances_ = (\\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\\n                                          self.covariance_type))\\n        self.weights_ /= n_samples\\n        self.precisions_cholesky_ = _compute_precision_cholesky(\\n            self.covariances_, self.covariance_type)\\n\\n    def _estimate_log_prob(self, X):\\n        return _estimate_log_gaussian_prob(\\n            X, self.means_, self.precisions_cholesky_, self.covariance_type)\\n\\n    def _estimate_log_weights(self):\\n        return np.log(self.weights_)\\n\\n    def _compute_lower_bound(self, _, log_prob_norm):\\n        return log_prob_norm\\n",
          "lines_count": 28
        },
        {
          "file_path": "sklearn/mixture/base.py",
          "start_line": 194,
          "end_line": 276,
          "content": "    def fit_predict(self, X, y=None):\\n        \"\"\"Estimate model parameters using X and predict the labels for X.\\n\\n        The method fits the model n_init times and sets the parameters with\\n        which the model has the largest likelihood or lower bound. Within each\\n        trial, the method iterates between E-step and M-step for `max_iter`\\n        times until the change of likelihood or lower bound is less than\\n        `tol`, otherwise, a `ConvergenceWarning` is raised. After fitting, it\\n        predicts the most probable label for the input data points.\\n\\n        .. versionadded:: 0.20\\n\\n        Parameters\\n        ----------\\n        X : array-like, shape (n_samples, n_features)\\n            List of n_features-dimensional data points. Each row\\n            corresponds to a single data point.\\n\\n        Returns\\n        -------\\n        labels : array, shape (n_samples,)\\n            Component labels.\\n        \"\"\"\\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\\n        self._check_initial_parameters(X)\\n\\n        # if we enable warm_start, we will have a unique initialisation\\n        do_init = not(self.warm_start and hasattr(self, \\",
          "lines_count": 83
        },
        {
          "file_path": "sklearn/mixture/base.py",
          "start_line": 358,
          "end_line": 374,
          "content": "    def predict(self, X):\\n        \"\"\"Predict the labels for the data samples in X using trained model.\\n\\n        Parameters\\n        ----------\\n        X : array-like, shape (n_samples, n_features)\\n            List of n_features-dimensional data points. Each row\\n            corresponds to a single data point.\\n\\n        Returns\\n        -------\\n        labels : array, shape (n_samples,)\\n            Component labels.\\n        \"\"\"\\n        self._check_is_fitted()\\n        X = _check_X(X, None, self.means_.shape[1])\\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\\n",
          "lines_count": 17
        },
        {
          "file_path": "sklearn/mixture/base.py",
          "start_line": 131,
          "end_line": 155,
          "content": "    def _initialize_parameters(self, X, random_state):\\n        \"\"\"Initialize the model parameters.\\n\\n        Parameters\\n        ----------\\n        X : array-like, shape  (n_samples, n_features)\\n\\n        random_state : RandomState\\n            A random number generator instance.\\n        \"\"\"\\n        n_samples, _ = X.shape\\n\\n        if self.init_params == \\",
          "lines_count": 25
        },
        {
          "file_path": "sklearn/mixture/gaussian_mixture.py",
          "start_line": 272,
          "end_line": 274,
          "content": "        self._set_parameters(best_params)\\n        self.n_iter_ = best_n_iter\\n        self.lower_bound_ = max_lower_bound\\n",
          "lines_count": 3
        },
        {
          "file_path": "sklearn/mixture/gaussian_mixture.py",
          "start_line": 660,
          "end_line": 687,
          "content": "    def _m_step(self, X, log_resp):\\n        \"\"\"M step.\\n\\n        Parameters\\n        ----------\\n        X : array-like, shape (n_samples, n_features)\\n\\n        log_resp : array-like, shape (n_samples, n_components)\\n            Logarithm of the posterior probabilities (or responsibilities) of\\n            the point of each sample in X.\\n        \"\"\"\\n        n_samples, _ = X.shape\\n        self.weights_, self.means_, self.covariances_ = (\\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\\n                                          self.covariance_type))\\n        self.weights_ /= n_samples\\n        self.precisions_cholesky_ = _compute_precision_cholesky(\\n            self.covariances_, self.covariance_type)\\n\\n    def _estimate_log_prob(self, X):\\n        return _estimate_log_gaussian_prob(\\n            X, self.means_, self.precisions_cholesky_, self.covariance_type)\\n\\n    def _estimate_log_weights(self):\\n        return np.log(self.weights_)\\n\\n    def _compute_lower_bound(self, _, log_prob_norm):\\n        return log_prob_norm\\n",
          "lines_count": 28
        }
      ],
      "test_results": {
        "overall_success": false,
        "issue_resolved": false
      },
      "gold_patch_analysis": {
        "modified_files": [
          "sklearn/mixture/base.py"
        ],
        "context_files": [
          "sklearn/mixture/tests/test_gaussian_mixture.py",
          "sklearn/mixture/gaussian_mixture.py",
          "sklearn/mixture/base.py"
        ],
        "file_coverage": 1.0,
        "covered_files": [
          "sklearn/mixture/base.py"
        ],
        "missed_files": [],
        "total_code_blocks": 2,
        "covered_code_blocks": 2,
        "code_block_coverage": 1.0,
        "code_blocks_detail": [
          {
            "file_path": "sklearn/mixture/base.py",
            "old_start_line": 257,
            "new_start_line": 257,
            "hunk_content": "                 best_params = self._get_parameters()\n                 best_n_iter = n_iter\n \n-        # Always do a final e-step to guarantee that the labels returned by\n-        # fit_predict(X) are always consistent with fit(X).predict(X)\n-        # for any value of max_iter and tol (and any random_state).\n-        _, log_resp = self._e_step(X)\n-\n         if not self.converged_:\n             warnings.warn('Initialization %d did not converge. '\n                           'Try different init parameters, '",
            "added_lines": [],
            "removed_lines": [
              "-        # Always do a final e-step to guarantee that the labels returned by",
              "-        # fit_predict(X) are always consistent with fit(X).predict(X)",
              "-        # for any value of max_iter and tol (and any random_state).",
              "-        _, log_resp = self._e_step(X)",
              "-"
            ],
            "new_end_line": 262,
            "enclosing_functions": [],
            "enclosing_classes": []
          },
          {
            "file_path": "sklearn/mixture/base.py",
            "old_start_line": 273,
            "new_start_line": 268,
            "hunk_content": "         self.n_iter_ = best_n_iter\n         self.lower_bound_ = max_lower_bound\n \n+        # Always do a final e-step to guarantee that the labels returned by\n+        # fit_predict(X) are always consistent with fit(X).predict(X)\n+        # for any value of max_iter and tol (and any random_state).\n+        _, log_resp = self._e_step(X)\n+\n         return log_resp.argmax(axis=1)\n \n     def _e_step(self, X):\n",
            "added_lines": [
              "+        # Always do a final e-step to guarantee that the labels returned by",
              "+        # fit_predict(X) are always consistent with fit(X).predict(X)",
              "+        # for any value of max_iter and tol (and any random_state).",
              "+        _, log_resp = self._e_step(X)",
              "+"
            ],
            "removed_lines": [],
            "new_end_line": 279,
            "enclosing_functions": [
              "_e_step"
            ],
            "enclosing_classes": []
          }
        ],
        "function_coverage": {
          "total_functions": 1,
          "covered_functions": 0,
          "coverage_rate": 0.0,
          "patch_functions": [
            {
              "name": "_e_step",
              "file": "sklearn/mixture/base.py",
              "line": null,
              "type": "function"
            }
          ],
          "context_functions": [
            {
              "name": "test_gaussian_mixture_fit_predict",
              "line": 580,
              "type": "function",
              "file": "sklearn/mixture/tests/test_gaussian_mixture.py"
            },
            {
              "name": "test_multiple_init",
              "line": 688,
              "type": "function",
              "file": "sklearn/mixture/tests/test_gaussian_mixture.py"
            },
            {
              "name": "test_gaussian_mixture_predict_predict_proba",
              "line": 548,
              "type": "function",
              "file": "sklearn/mixture/tests/test_gaussian_mixture.py"
            },
            {
              "name": "test_gaussian_mixture_fit_predict",
              "line": 580,
              "type": "function",
              "file": "sklearn/mixture/tests/test_gaussian_mixture.py"
            },
            {
              "name": "test_multiple_init",
              "line": 688,
              "type": "function",
              "file": "sklearn/mixture/tests/test_gaussian_mixture.py"
            },
            {
              "name": "test_gaussian_mixture_predict_predict_proba",
              "line": 548,
              "type": "function",
              "file": "sklearn/mixture/tests/test_gaussian_mixture.py"
            },
            {
              "name": "fit_predict",
              "line": 194,
              "type": "function",
              "file": "sklearn/mixture/base.py"
            },
            {
              "name": "predict",
              "line": 358,
              "type": "function",
              "file": "sklearn/mixture/base.py"
            },
            {
              "name": "_initialize_parameters",
              "line": 131,
              "type": "function",
              "file": "sklearn/mixture/base.py"
            },
            {
              "name": "fit_predict",
              "line": 194,
              "type": "function",
              "file": "sklearn/mixture/base.py"
            },
            {
              "name": "predict",
              "line": 358,
              "type": "function",
              "file": "sklearn/mixture/base.py"
            },
            {
              "name": "_initialize_parameters",
              "line": 131,
              "type": "function",
              "file": "sklearn/mixture/base.py"
            },
            {
              "name": "_m_step",
              "line": 660,
              "type": "function",
              "file": "sklearn/mixture/gaussian_mixture.py"
            },
            {
              "name": "fit_predict",
              "line": 194,
              "type": "function",
              "file": "sklearn/mixture/base.py"
            },
            {
              "name": "predict",
              "line": 358,
              "type": "function",
              "file": "sklearn/mixture/base.py"
            },
            {
              "name": "_initialize_parameters",
              "line": 131,
              "type": "function",
              "file": "sklearn/mixture/base.py"
            },
            {
              "name": "_m_step",
              "line": 660,
              "type": "function",
              "file": "sklearn/mixture/gaussian_mixture.py"
            }
          ]
        },
        "class_coverage": {
          "total_classes": 0,
          "covered_classes": 0,
          "coverage_rate": 0,
          "patch_classes": [],
          "context_classes": [
            {
              "name": "GaussianMixture",
              "line": 434,
              "type": "class",
              "file": "sklearn/mixture/gaussian_mixture.py"
            },
            {
              "name": "BaseMixture",
              "line": 64,
              "type": "class",
              "file": "sklearn/mixture/base.py"
            },
            {
              "name": "GaussianMixture",
              "line": 434,
              "type": "class",
              "file": "sklearn/mixture/gaussian_mixture.py"
            },
            {
              "name": "BaseMixture",
              "line": 64,
              "type": "class",
              "file": "sklearn/mixture/base.py"
            }
          ]
        }
      }
    },
    {
      "instance_id": "django__django-13401",
      "project": "django",
      "total_contexts_found": 33,
      "unique_files_accessed": 7,
      "contexts_detail": [
        {
          "file_path": "tests/model_fields/test_field_flags.py",
          "start_line": 71,
          "end_line": 98,
          "content": "class FieldFlagsTests(test.SimpleTestCase):\\n    @classmethod\\n    def setUpClass(cls):\\n        super().setUpClass()\\n        cls.fields = [\\n            *AllFieldsModel._meta.fields,\\n            *AllFieldsModel._meta.private_fields,\\n        ]\\n\\n        cls.all_fields = [\\n            *cls.fields,\\n            *AllFieldsModel._meta.many_to_many,\\n            *AllFieldsModel._meta.private_fields,\\n        ]\\n\\n        cls.fields_and_reverse_objects = [\\n            *cls.all_fields,\\n            *AllFieldsModel._meta.related_objects,\\n        ]\\n\\n    def test_each_field_should_have_a_concrete_attribute(self):\\n        self.assertTrue(all(f.concrete.__class__ == bool for f in self.fields))\\n\\n    def test_each_field_should_have_an_editable_attribute(self):\\n        self.assertTrue(all(f.editable.__class__ == bool for f in self.all_fields))\\n\\n    def test_each_field_should_have_a_has_rel_attribute(self):\\n        self.assertTrue(all(f.is_relation.__class__ == bool for f in self.all_fields))\\n",
          "lines_count": 28
        },
        {
          "file_path": "tests/model_forms/tests.py",
          "start_line": 2770,
          "end_line": 2819,
          "content": "class LimitChoicesToTests(TestCase):\\n    \"\"\"\\n    Tests the functionality of ``limit_choices_to``.\\n    \"\"\"\\n    @classmethod\\n    def setUpTestData(cls):\\n        cls.threepwood = Character.objects.create(\\n            username=\\",
          "lines_count": 50
        },
        {
          "file_path": "tests/validation/tests.py",
          "start_line": 92,
          "end_line": 134,
          "content": "class ModelFormsTests(TestCase):\\n    @classmethod\\n    def setUpTestData(cls):\\n        cls.author = Author.objects.create(name=\\",
          "lines_count": 43
        },
        {
          "file_path": "tests/model_fields/test_field_flags.py",
          "start_line": 71,
          "end_line": 98,
          "content": "class FieldFlagsTests(test.SimpleTestCase):\\n    @classmethod\\n    def setUpClass(cls):\\n        super().setUpClass()\\n        cls.fields = [\\n            *AllFieldsModel._meta.fields,\\n            *AllFieldsModel._meta.private_fields,\\n        ]\\n\\n        cls.all_fields = [\\n            *cls.fields,\\n            *AllFieldsModel._meta.many_to_many,\\n            *AllFieldsModel._meta.private_fields,\\n        ]\\n\\n        cls.fields_and_reverse_objects = [\\n            *cls.all_fields,\\n            *AllFieldsModel._meta.related_objects,\\n        ]\\n\\n    def test_each_field_should_have_a_concrete_attribute(self):\\n        self.assertTrue(all(f.concrete.__class__ == bool for f in self.fields))\\n\\n    def test_each_field_should_have_an_editable_attribute(self):\\n        self.assertTrue(all(f.editable.__class__ == bool for f in self.all_fields))\\n\\n    def test_each_field_should_have_a_has_rel_attribute(self):\\n        self.assertTrue(all(f.is_relation.__class__ == bool for f in self.all_fields))\\n",
          "lines_count": 28
        },
        {
          "file_path": "tests/model_forms/tests.py",
          "start_line": 2770,
          "end_line": 2819,
          "content": "class LimitChoicesToTests(TestCase):\\n    \"\"\"\\n    Tests the functionality of ``limit_choices_to``.\\n    \"\"\"\\n    @classmethod\\n    def setUpTestData(cls):\\n        cls.threepwood = Character.objects.create(\\n            username=\\",
          "lines_count": 50
        },
        {
          "file_path": "tests/validation/tests.py",
          "start_line": 92,
          "end_line": 134,
          "content": "class ModelFormsTests(TestCase):\\n    @classmethod\\n    def setUpTestData(cls):\\n        cls.author = Author.objects.create(name=\\",
          "lines_count": 43
        },
        {
          "file_path": "tests/model_inheritance/models.py",
          "start_line": 71,
          "end_line": 98,
          "content": "",
          "lines_count": 28
        },
        {
          "file_path": "tests/model_forms/tests.py",
          "start_line": 2770,
          "end_line": 2819,
          "content": "class LimitChoicesToTests(TestCase):\\n    \"\"\"\\n    Tests the functionality of ``limit_choices_to``.\\n    \"\"\"\\n    @classmethod\\n    def setUpTestData(cls):\\n        cls.threepwood = Character.objects.create(\\n            username=\\",
          "lines_count": 50
        },
        {
          "file_path": "tests/validation/tests.py",
          "start_line": 92,
          "end_line": 134,
          "content": "class ModelFormsTests(TestCase):\\n    @classmethod\\n    def setUpTestData(cls):\\n        cls.author = Author.objects.create(name=\\",
          "lines_count": 43
        },
        {
          "file_path": "tests/model_inheritance/models.py",
          "start_line": 71,
          "end_line": 219,
          "content": "class FieldFlagsTests(test.SimpleTestCase):\\n    @classmethod\\n    def setUpClass(cls):\\n        super().setUpClass()\\n        cls.fields = [\\n            *AllFieldsModel._meta.fields,\\n            *AllFieldsModel._meta.private_fields,\\n        ]\\n\\n        cls.all_fields = [\\n            *cls.fields,\\n            *AllFieldsModel._meta.many_to_many,\\n            *AllFieldsModel._meta.private_fields,\\n        ]\\n\\n        cls.fields_and_reverse_objects = [\\n            *cls.all_fields,\\n            *AllFieldsModel._meta.related_objects,\\n        ]\\n\\n    def test_each_field_should_have_a_concrete_attribute(self):\\n        self.assertTrue(all(f.concrete.__class__ == bool for f in self.fields))\\n\\n    def test_each_field_should_have_an_editable_attribute(self):\\n        self.assertTrue(all(f.editable.__class__ == bool for f in self.all_fields))\\n\\n    def test_each_field_should_have_a_has_rel_attribute(self):\\n        self.assertTrue(all(f.is_relation.__class__ == bool for f in self.all_fields))\\n\\n    def test_each_object_should_have_auto_created(self):\\n        self.assertTrue(\\n            all(f.auto_created.__class__ == bool for f in self.fields_and_reverse_objects)\\n        )\\n\\n    def test_non_concrete_fields(self):\\n        for field in self.fields:\\n            if type(field) in NON_CONCRETE_FIELDS:\\n                self.assertFalse(field.concrete)\\n            else:\\n                self.assertTrue(field.concrete)\\n\\n    def test_non_editable_fields(self):\\n        for field in self.all_fields:\\n            if type(field) in NON_EDITABLE_FIELDS:\\n                self.assertFalse(field.editable)\\n            else:\\n                self.assertTrue(field.editable)\\n\\n    def test_related_fields(self):\\n        for field in self.all_fields:\\n            if type(field) in RELATION_FIELDS:\\n                self.assertTrue(field.is_relation)\\n            else:\\n                self.assertFalse(field.is_relation)\\n\\n    def test_field_names_should_always_be_available(self):\\n        for field in self.fields_and_reverse_objects:\\n            self.assertTrue(field.name)\\n\\n    def test_all_field_types_should_have_flags(self):\\n        for field in self.fields_and_reverse_objects:\\n            for flag in FLAG_PROPERTIES:\\n                self.assertTrue(hasattr(field, flag), \"Field %s does not have flag %s\" % (field, flag))\\n            if field.is_relation:\\n                true_cardinality_flags = sum(\\n                    getattr(field, flag) is True\\n                    for flag in FLAG_PROPERTIES_FOR_RELATIONS\\n                )\\n                # If the field has a relation, there should be only one of the\\n                # 4 cardinality flags available.\\n                self.assertEqual(1, true_cardinality_flags)\\n\\n    def test_cardinality_m2m(self):\\n        m2m_type_fields = [\\n            f for f in self.all_fields\\n            if f.is_relation and f.many_to_many\\n        ]\\n        # Test classes are what we expect\\n        self.assertEqual(MANY_TO_MANY_CLASSES, {f.__class__ for f in m2m_type_fields})\\n\\n        # Ensure all m2m reverses are m2m\\n        for field in m2m_type_fields:\\n            reverse_field = field.remote_field\\n            self.assertTrue(reverse_field.is_relation)\\n            self.assertTrue(reverse_field.many_to_many)\\n            self.assertTrue(reverse_field.related_model)\\n\\n    def test_cardinality_o2m(self):\\n        o2m_type_fields = [\\n            f for f in self.fields_and_reverse_objects\\n            if f.is_relation and f.one_to_many\\n        ]\\n        # Test classes are what we expect\\n        self.assertEqual(ONE_TO_MANY_CLASSES, {f.__class__ for f in o2m_type_fields})\\n\\n        # Ensure all o2m reverses are m2o\\n        for field in o2m_type_fields:\\n            if field.concrete:\\n                reverse_field = field.remote_field\\n                self.assertTrue(reverse_field.is_relation and reverse_field.many_to_one)\\n\\n    def test_cardinality_m2o(self):\\n        m2o_type_fields = [\\n            f for f in self.fields_and_reverse_objects\\n            if f.is_relation and f.many_to_one\\n        ]\\n        # Test classes are what we expect\\n        self.assertEqual(MANY_TO_ONE_CLASSES, {f.__class__ for f in m2o_type_fields})\\n\\n        # Ensure all m2o reverses are o2m\\n        for obj in m2o_type_fields:\\n            if hasattr(obj, \\",
          "lines_count": 149
        },
        {
          "file_path": "tests/model_fields/test_field_flags.py",
          "start_line": 71,
          "end_line": 98,
          "content": "class FieldFlagsTests(test.SimpleTestCase):\\n    @classmethod\\n    def setUpClass(cls):\\n        super().setUpClass()\\n        cls.fields = [\\n            *AllFieldsModel._meta.fields,\\n            *AllFieldsModel._meta.private_fields,\\n        ]\\n\\n        cls.all_fields = [\\n            *cls.fields,\\n            *AllFieldsModel._meta.many_to_many,\\n            *AllFieldsModel._meta.private_fields,\\n        ]\\n\\n        cls.fields_and_reverse_objects = [\\n            *cls.all_fields,\\n            *AllFieldsModel._meta.related_objects,\\n        ]\\n\\n    def test_each_field_should_have_a_concrete_attribute(self):\\n        self.assertTrue(all(f.concrete.__class__ == bool for f in self.fields))\\n\\n    def test_each_field_should_have_an_editable_attribute(self):\\n        self.assertTrue(all(f.editable.__class__ == bool for f in self.all_fields))\\n\\n    def test_each_field_should_have_a_has_rel_attribute(self):\\n        self.assertTrue(all(f.is_relation.__class__ == bool for f in self.all_fields))\\n",
          "lines_count": 28
        },
        {
          "file_path": "tests/model_forms/tests.py",
          "start_line": 2770,
          "end_line": 2819,
          "content": "class LimitChoicesToTests(TestCase):\\n    \"\"\"\\n    Tests the functionality of ``limit_choices_to``.\\n    \"\"\"\\n    @classmethod\\n    def setUpTestData(cls):\\n        cls.threepwood = Character.objects.create(\\n            username=\\",
          "lines_count": 50
        },
        {
          "file_path": "tests/validation/tests.py",
          "start_line": 92,
          "end_line": 134,
          "content": "class ModelFormsTests(TestCase):\\n    @classmethod\\n    def setUpTestData(cls):\\n        cls.author = Author.objects.create(name=\\",
          "lines_count": 43
        },
        {
          "file_path": "tests/model_inheritance/models.py",
          "start_line": 71,
          "end_line": 219,
          "content": "class FieldFlagsTests(test.SimpleTestCase):\\n    @classmethod\\n    def setUpClass(cls):\\n        super().setUpClass()\\n        cls.fields = [\\n            *AllFieldsModel._meta.fields,\\n            *AllFieldsModel._meta.private_fields,\\n        ]\\n\\n        cls.all_fields = [\\n            *cls.fields,\\n            *AllFieldsModel._meta.many_to_many,\\n            *AllFieldsModel._meta.private_fields,\\n        ]\\n\\n        cls.fields_and_reverse_objects = [\\n            *cls.all_fields,\\n            *AllFieldsModel._meta.related_objects,\\n        ]\\n\\n    def test_each_field_should_have_a_concrete_attribute(self):\\n        self.assertTrue(all(f.concrete.__class__ == bool for f in self.fields))\\n\\n    def test_each_field_should_have_an_editable_attribute(self):\\n        self.assertTrue(all(f.editable.__class__ == bool for f in self.all_fields))\\n\\n    def test_each_field_should_have_a_has_rel_attribute(self):\\n        self.assertTrue(all(f.is_relation.__class__ == bool for f in self.all_fields))\\n\\n    def test_each_object_should_have_auto_created(self):\\n        self.assertTrue(\\n            all(f.auto_created.__class__ == bool for f in self.fields_and_reverse_objects)\\n        )\\n\\n    def test_non_concrete_fields(self):\\n        for field in self.fields:\\n            if type(field) in NON_CONCRETE_FIELDS:\\n                self.assertFalse(field.concrete)\\n            else:\\n                self.assertTrue(field.concrete)\\n\\n    def test_non_editable_fields(self):\\n        for field in self.all_fields:\\n            if type(field) in NON_EDITABLE_FIELDS:\\n                self.assertFalse(field.editable)\\n            else:\\n                self.assertTrue(field.editable)\\n\\n    def test_related_fields(self):\\n        for field in self.all_fields:\\n            if type(field) in RELATION_FIELDS:\\n                self.assertTrue(field.is_relation)\\n            else:\\n                self.assertFalse(field.is_relation)\\n\\n    def test_field_names_should_always_be_available(self):\\n        for field in self.fields_and_reverse_objects:\\n            self.assertTrue(field.name)\\n\\n    def test_all_field_types_should_have_flags(self):\\n        for field in self.fields_and_reverse_objects:\\n            for flag in FLAG_PROPERTIES:\\n                self.assertTrue(hasattr(field, flag), \"Field %s does not have flag %s\" % (field, flag))\\n            if field.is_relation:\\n                true_cardinality_flags = sum(\\n                    getattr(field, flag) is True\\n                    for flag in FLAG_PROPERTIES_FOR_RELATIONS\\n                )\\n                # If the field has a relation, there should be only one of the\\n                # 4 cardinality flags available.\\n                self.assertEqual(1, true_cardinality_flags)\\n\\n    def test_cardinality_m2m(self):\\n        m2m_type_fields = [\\n            f for f in self.all_fields\\n            if f.is_relation and f.many_to_many\\n        ]\\n        # Test classes are what we expect\\n        self.assertEqual(MANY_TO_MANY_CLASSES, {f.__class__ for f in m2m_type_fields})\\n\\n        # Ensure all m2m reverses are m2m\\n        for field in m2m_type_fields:\\n            reverse_field = field.remote_field\\n            self.assertTrue(reverse_field.is_relation)\\n            self.assertTrue(reverse_field.many_to_many)\\n            self.assertTrue(reverse_field.related_model)\\n\\n    def test_cardinality_o2m(self):\\n        o2m_type_fields = [\\n            f for f in self.fields_and_reverse_objects\\n            if f.is_relation and f.one_to_many\\n        ]\\n        # Test classes are what we expect\\n        self.assertEqual(ONE_TO_MANY_CLASSES, {f.__class__ for f in o2m_type_fields})\\n\\n        # Ensure all o2m reverses are m2o\\n        for field in o2m_type_fields:\\n            if field.concrete:\\n                reverse_field = field.remote_field\\n                self.assertTrue(reverse_field.is_relation and reverse_field.many_to_one)\\n\\n    def test_cardinality_m2o(self):\\n        m2o_type_fields = [\\n            f for f in self.fields_and_reverse_objects\\n            if f.is_relation and f.many_to_one\\n        ]\\n        # Test classes are what we expect\\n        self.assertEqual(MANY_TO_ONE_CLASSES, {f.__class__ for f in m2o_type_fields})\\n\\n        # Ensure all m2o reverses are o2m\\n        for obj in m2o_type_fields:\\n            if hasattr(obj, \\",
          "lines_count": 149
        },
        {
          "file_path": "django/db/models/base.py",
          "start_line": 404,
          "end_line": 600,
          "content": "class Model(metaclass=ModelBase):\\n\\n    def __init__(self, *args, **kwargs):\\n        # Alias some things as locals to avoid repeat global lookups\\n        cls = self.__class__\\n        opts = self._meta\\n        _setattr = setattr\\n        _DEFERRED = DEFERRED\\n        if opts.abstract:\\n            raise TypeError(\\",
          "lines_count": 197
        },
        {
          "file_path": "django/db/models/base.py",
          "start_line": 404,
          "end_line": 600,
          "content": "class Model(metaclass=ModelBase):\\n\\n    def __init__(self, *args, **kwargs):\\n        # Alias some things as locals to avoid repeat global lookups\\n        cls = self.__class__\\n        opts = self._meta\\n        _setattr = setattr\\n        _DEFERRED = DEFERRED\\n        if opts.abstract:\\n            raise TypeError(\\",
          "lines_count": 197
        },
        {
          "file_path": "django/forms/fields.py",
          "start_line": 47,
          "end_line": 210,
          "content": "class Field:\\n    widget = TextInput  # Default widget to use when rendering this type of Field.\\n    hidden_widget = HiddenInput  # Default widget to use when rendering this as \"hidden\".\\n    default_validators = []  # Default set of validators\\n    # Add an \\",
          "lines_count": 164
        },
        {
          "file_path": "django/db/models/base.py",
          "start_line": 404,
          "end_line": 600,
          "content": "class Model(metaclass=ModelBase):\\n\\n    def __init__(self, *args, **kwargs):\\n        # Alias some things as locals to avoid repeat global lookups\\n        cls = self.__class__\\n        opts = self._meta\\n        _setattr = setattr\\n        _DEFERRED = DEFERRED\\n        if opts.abstract:\\n            raise TypeError(\\",
          "lines_count": 197
        },
        {
          "file_path": "django/forms/fields.py",
          "start_line": 47,
          "end_line": 210,
          "content": "class Field:\\n    widget = TextInput  # Default widget to use when rendering this type of Field.\\n    hidden_widget = HiddenInput  # Default widget to use when rendering this as \"hidden\".\\n    default_validators = []  # Default set of validators\\n    # Add an \\",
          "lines_count": 164
        },
        {
          "file_path": "django/db/models/base.py",
          "start_line": 404,
          "end_line": 600,
          "content": "class Model(metaclass=ModelBase):\\n\\n    def __init__(self, *args, **kwargs):\\n        # Alias some things as locals to avoid repeat global lookups\\n        cls = self.__class__\\n        opts = self._meta\\n        _setattr = setattr\\n        _DEFERRED = DEFERRED\\n        if opts.abstract:\\n            raise TypeError(\\",
          "lines_count": 197
        },
        {
          "file_path": "django/forms/fields.py",
          "start_line": 47,
          "end_line": 210,
          "content": "class Field:\\n    widget = TextInput  # Default widget to use when rendering this type of Field.\\n    hidden_widget = HiddenInput  # Default widget to use when rendering this as \"hidden\".\\n    default_validators = []  # Default set of validators\\n    # Add an \\",
          "lines_count": 164
        },
        {
          "file_path": "django/forms/fields.py",
          "start_line": 244,
          "end_line": 287,
          "content": "class IntegerField(Field):\\n    widget = NumberInput\\n    default_error_messages = {\\n        \\",
          "lines_count": 44
        },
        {
          "file_path": "django/db/models/base.py",
          "start_line": 404,
          "end_line": 2035,
          "content": "class Model(metaclass=ModelBase):\\n\\n    def __init__(self, *args, **kwargs):\\n        # Alias some things as locals to avoid repeat global lookups\\n        cls = self.__class__\\n        opts = self._meta\\n        _setattr = setattr\\n        _DEFERRED = DEFERRED\\n        if opts.abstract:\\n            raise TypeError(\\",
          "lines_count": 1632
        },
        {
          "file_path": "django/db/models/base.py",
          "start_line": 404,
          "end_line": 600,
          "content": "class Model(metaclass=ModelBase):\\n\\n    def __init__(self, *args, **kwargs):\\n        # Alias some things as locals to avoid repeat global lookups\\n        cls = self.__class__\\n        opts = self._meta\\n        _setattr = setattr\\n        _DEFERRED = DEFERRED\\n        if opts.abstract:\\n            raise TypeError(\\",
          "lines_count": 197
        },
        {
          "file_path": "django/forms/fields.py",
          "start_line": 47,
          "end_line": 210,
          "content": "class Field:\\n    widget = TextInput  # Default widget to use when rendering this type of Field.\\n    hidden_widget = HiddenInput  # Default widget to use when rendering this as \"hidden\".\\n    default_validators = []  # Default set of validators\\n    # Add an \\",
          "lines_count": 164
        },
        {
          "file_path": "django/forms/fields.py",
          "start_line": 244,
          "end_line": 287,
          "content": "class IntegerField(Field):\\n    widget = NumberInput\\n    default_error_messages = {\\n        \\",
          "lines_count": 44
        },
        {
          "file_path": "django/db/models/base.py",
          "start_line": 404,
          "end_line": 2035,
          "content": "class Model(metaclass=ModelBase):\\n\\n    def __init__(self, *args, **kwargs):\\n        # Alias some things as locals to avoid repeat global lookups\\n        cls = self.__class__\\n        opts = self._meta\\n        _setattr = setattr\\n        _DEFERRED = DEFERRED\\n        if opts.abstract:\\n            raise TypeError(\\",
          "lines_count": 1632
        },
        {
          "file_path": "django/db/models/fields/__init__.py",
          "start_line": 84,
          "end_line": 933,
          "content": "@total_ordering\\nclass Field(RegisterLookupMixin):\\n    \"\"\"Base class for all field types\"\"\"\\n\\n    # Designates whether empty strings fundamentally are allowed at the\\n    # database level.\\n    empty_strings_allowed = True\\n    empty_values = list(validators.EMPTY_VALUES)\\n\\n    # These track each time a Field instance is created. Used to retain order.\\n    # The auto_creation_counter is used for fields that Django implicitly\\n    # creates, creation_counter is used for all user-specified fields.\\n    creation_counter = 0\\n    auto_creation_counter = -1\\n    default_validators = []  # Default set of validators\\n    default_error_messages = {\\n        \\",
          "lines_count": 850
        },
        {
          "file_path": "django/db/models/base.py",
          "start_line": 404,
          "end_line": 600,
          "content": "class Model(metaclass=ModelBase):\\n\\n    def __init__(self, *args, **kwargs):\\n        # Alias some things as locals to avoid repeat global lookups\\n        cls = self.__class__\\n        opts = self._meta\\n        _setattr = setattr\\n        _DEFERRED = DEFERRED\\n        if opts.abstract:\\n            raise TypeError(\\",
          "lines_count": 197
        },
        {
          "file_path": "django/forms/fields.py",
          "start_line": 47,
          "end_line": 210,
          "content": "class Field:\\n    widget = TextInput  # Default widget to use when rendering this type of Field.\\n    hidden_widget = HiddenInput  # Default widget to use when rendering this as \"hidden\".\\n    default_validators = []  # Default set of validators\\n    # Add an \\",
          "lines_count": 164
        },
        {
          "file_path": "django/forms/fields.py",
          "start_line": 244,
          "end_line": 287,
          "content": "class IntegerField(Field):\\n    widget = NumberInput\\n    default_error_messages = {\\n        \\",
          "lines_count": 44
        },
        {
          "file_path": "django/db/models/base.py",
          "start_line": 404,
          "end_line": 2035,
          "content": "class Model(metaclass=ModelBase):\\n\\n    def __init__(self, *args, **kwargs):\\n        # Alias some things as locals to avoid repeat global lookups\\n        cls = self.__class__\\n        opts = self._meta\\n        _setattr = setattr\\n        _DEFERRED = DEFERRED\\n        if opts.abstract:\\n            raise TypeError(\\",
          "lines_count": 1632
        },
        {
          "file_path": "django/db/models/fields/__init__.py",
          "start_line": 84,
          "end_line": 933,
          "content": "@total_ordering\\nclass Field(RegisterLookupMixin):\\n    \"\"\"Base class for all field types\"\"\"\\n\\n    # Designates whether empty strings fundamentally are allowed at the\\n    # database level.\\n    empty_strings_allowed = True\\n    empty_values = list(validators.EMPTY_VALUES)\\n\\n    # These track each time a Field instance is created. Used to retain order.\\n    # The auto_creation_counter is used for fields that Django implicitly\\n    # creates, creation_counter is used for all user-specified fields.\\n    creation_counter = 0\\n    auto_creation_counter = -1\\n    default_validators = []  # Default set of validators\\n    default_error_messages = {\\n        \\",
          "lines_count": 850
        }
      ],
      "test_results": {
        "overall_success": false,
        "issue_resolved": false
      },
      "gold_patch_analysis": {
        "modified_files": [
          "django/db/models/fields/__init__.py"
        ],
        "context_files": [
          "tests/model_forms/tests.py",
          "django/db/models/base.py",
          "tests/validation/tests.py",
          "django/forms/fields.py",
          "tests/model_inheritance/models.py",
          "tests/model_fields/test_field_flags.py",
          "django/db/models/fields/__init__.py"
        ],
        "file_coverage": 1.0,
        "covered_files": [
          "django/db/models/fields/__init__.py"
        ],
        "missed_files": [],
        "total_code_blocks": 1,
        "covered_code_blocks": 1,
        "code_block_coverage": 1.0,
        "code_blocks_detail": [
          {
            "file_path": "django/db/models/fields/__init__.py",
            "old_start_line": 516,
            "new_start_line": 516,
            "hunk_content": "     def __eq__(self, other):\n         # Needed for @total_ordering\n         if isinstance(other, Field):\n-            return self.creation_counter == other.creation_counter\n+            return (\n+                self.creation_counter == other.creation_counter and\n+                getattr(self, 'model', None) == getattr(other, 'model', None)\n+            )\n         return NotImplemented\n \n     def __lt__(self, other):\n         # This is needed because bisect does not take a comparison function.\n+        # Order by creation_counter first for backward compatibility.\n         if isinstance(other, Field):\n-            return self.creation_counter < other.creation_counter\n+            if (\n+                self.creation_counter != other.creation_counter or\n+                not hasattr(self, 'model') and not hasattr(other, 'model')\n+            ):\n+                return self.creation_counter < other.creation_counter\n+            elif hasattr(self, 'model') != hasattr(other, 'model'):\n+                return not hasattr(self, 'model')  # Order no-model fields first\n+            else:\n+                # creation_counter's are equal, compare only models.\n+                return (\n+                    (self.model._meta.app_label, self.model._meta.model_name) <\n+                    (other.model._meta.app_label, other.model._meta.model_name)\n+                )\n         return NotImplemented\n \n     def __hash__(self):\n-        return hash(self.creation_counter)\n+        return hash((\n+            self.creation_counter,\n+            self.model._meta.app_label if hasattr(self, 'model') else None,\n+            self.model._meta.model_name if hasattr(self, 'model') else None,\n+        ))\n \n     def __deepcopy__(self, memodict):\n         # We don't have to deepcopy very much here, since most things are not\n",
            "added_lines": [
              "+            return (",
              "+                self.creation_counter == other.creation_counter and",
              "+                getattr(self, 'model', None) == getattr(other, 'model', None)",
              "+            )",
              "+        # Order by creation_counter first for backward compatibility.",
              "+            if (",
              "+                self.creation_counter != other.creation_counter or",
              "+                not hasattr(self, 'model') and not hasattr(other, 'model')",
              "+            ):",
              "+                return self.creation_counter < other.creation_counter",
              "+            elif hasattr(self, 'model') != hasattr(other, 'model'):",
              "+                return not hasattr(self, 'model')  # Order no-model fields first",
              "+            else:",
              "+                # creation_counter's are equal, compare only models.",
              "+                return (",
              "+                    (self.model._meta.app_label, self.model._meta.model_name) <",
              "+                    (other.model._meta.app_label, other.model._meta.model_name)",
              "+                )",
              "+        return hash((",
              "+            self.creation_counter,",
              "+            self.model._meta.app_label if hasattr(self, 'model') else None,",
              "+            self.model._meta.model_name if hasattr(self, 'model') else None,",
              "+        ))"
            ],
            "removed_lines": [
              "-            return self.creation_counter == other.creation_counter",
              "-            return self.creation_counter < other.creation_counter",
              "-        return hash(self.creation_counter)"
            ],
            "new_end_line": 553,
            "enclosing_functions": [
              "__deepcopy__",
              "__eq__",
              "__hash__",
              "__lt__"
            ],
            "enclosing_classes": []
          }
        ],
        "function_coverage": {
          "total_functions": 4,
          "covered_functions": 0,
          "coverage_rate": 0.0,
          "patch_functions": [
            {
              "name": "__deepcopy__",
              "file": "django/db/models/fields/__init__.py",
              "line": null,
              "type": "function"
            },
            {
              "name": "__eq__",
              "file": "django/db/models/fields/__init__.py",
              "line": null,
              "type": "function"
            },
            {
              "name": "__hash__",
              "file": "django/db/models/fields/__init__.py",
              "line": null,
              "type": "function"
            },
            {
              "name": "__lt__",
              "file": "django/db/models/fields/__init__.py",
              "line": null,
              "type": "function"
            }
          ],
          "context_functions": []
        },
        "class_coverage": {
          "total_classes": 0,
          "covered_classes": 0,
          "coverage_rate": 0,
          "patch_classes": [],
          "context_classes": [
            {
              "name": "FieldFlagsTests",
              "line": 71,
              "type": "class",
              "file": "tests/model_fields/test_field_flags.py"
            },
            {
              "name": "LimitChoicesToTests",
              "line": 2770,
              "type": "class",
              "file": "tests/model_forms/tests.py"
            },
            {
              "name": "ModelFormsTests",
              "line": 92,
              "type": "class",
              "file": "tests/validation/tests.py"
            },
            {
              "name": "FieldFlagsTests",
              "line": 71,
              "type": "class",
              "file": "tests/model_fields/test_field_flags.py"
            },
            {
              "name": "LimitChoicesToTests",
              "line": 2770,
              "type": "class",
              "file": "tests/model_forms/tests.py"
            },
            {
              "name": "ModelFormsTests",
              "line": 92,
              "type": "class",
              "file": "tests/validation/tests.py"
            },
            {
              "name": "LimitChoicesToTests",
              "line": 2770,
              "type": "class",
              "file": "tests/model_forms/tests.py"
            },
            {
              "name": "ModelFormsTests",
              "line": 92,
              "type": "class",
              "file": "tests/validation/tests.py"
            },
            {
              "name": "FieldFlagsTests",
              "line": 71,
              "type": "class",
              "file": "tests/model_inheritance/models.py"
            },
            {
              "name": "FieldFlagsTests",
              "line": 71,
              "type": "class",
              "file": "tests/model_fields/test_field_flags.py"
            },
            {
              "name": "LimitChoicesToTests",
              "line": 2770,
              "type": "class",
              "file": "tests/model_forms/tests.py"
            },
            {
              "name": "ModelFormsTests",
              "line": 92,
              "type": "class",
              "file": "tests/validation/tests.py"
            },
            {
              "name": "FieldFlagsTests",
              "line": 71,
              "type": "class",
              "file": "tests/model_inheritance/models.py"
            },
            {
              "name": "Model",
              "line": 404,
              "type": "class",
              "file": "django/db/models/base.py"
            },
            {
              "name": "Model",
              "line": 404,
              "type": "class",
              "file": "django/db/models/base.py"
            },
            {
              "name": "Field",
              "line": 47,
              "type": "class",
              "file": "django/forms/fields.py"
            },
            {
              "name": "Model",
              "line": 404,
              "type": "class",
              "file": "django/db/models/base.py"
            },
            {
              "name": "Field",
              "line": 47,
              "type": "class",
              "file": "django/forms/fields.py"
            },
            {
              "name": "Model",
              "line": 404,
              "type": "class",
              "file": "django/db/models/base.py"
            },
            {
              "name": "Field",
              "line": 47,
              "type": "class",
              "file": "django/forms/fields.py"
            },
            {
              "name": "IntegerField",
              "line": 244,
              "type": "class",
              "file": "django/forms/fields.py"
            },
            {
              "name": "Model",
              "line": 404,
              "type": "class",
              "file": "django/db/models/base.py"
            },
            {
              "name": "Model",
              "line": 404,
              "type": "class",
              "file": "django/db/models/base.py"
            },
            {
              "name": "Field",
              "line": 47,
              "type": "class",
              "file": "django/forms/fields.py"
            },
            {
              "name": "IntegerField",
              "line": 244,
              "type": "class",
              "file": "django/forms/fields.py"
            },
            {
              "name": "Model",
              "line": 404,
              "type": "class",
              "file": "django/db/models/base.py"
            },
            {
              "name": "Model",
              "line": 404,
              "type": "class",
              "file": "django/db/models/base.py"
            },
            {
              "name": "Field",
              "line": 47,
              "type": "class",
              "file": "django/forms/fields.py"
            },
            {
              "name": "IntegerField",
              "line": 244,
              "type": "class",
              "file": "django/forms/fields.py"
            },
            {
              "name": "Model",
              "line": 404,
              "type": "class",
              "file": "django/db/models/base.py"
            }
          ]
        }
      }
    },
    {
      "instance_id": "sympy__sympy-16988",
      "project": "sympy",
      "total_contexts_found": 30,
      "unique_files_accessed": 6,
      "contexts_detail": [
        {
          "file_path": "sympy/sets/tests/test_sets.py",
          "start_line": 261,
          "end_line": 313,
          "content": "",
          "lines_count": 53
        },
        {
          "file_path": "doc/src/modules/solvers/solveset.rst",
          "start_line": 1,
          "end_line": 100,
          "content": ".. _solveset:\\n\\nSolveset\\n========\\n\\n.. module:: sympy.solvers.solveset\\n\\nThis is the official documentation of the ``solveset`` module in solvers.\\nIt contains the frequently asked questions about our new module to solve\\nequations.\\n\\nWhat\\",
          "lines_count": 100
        },
        {
          "file_path": "doc/src/modules/solvers/solveset.rst",
          "start_line": 261,
          "end_line": 313,
          "content": "",
          "lines_count": 53
        },
        {
          "file_path": "doc/src/modules/solvers/solveset.rst",
          "start_line": 1,
          "end_line": 100,
          "content": ".. _solveset:\\n\\nSolveset\\n========\\n\\n.. module:: sympy.solvers.solveset\\n\\nThis is the official documentation of the ``solveset`` module in solvers.\\nIt contains the frequently asked questions about our new module to solve\\nequations.\\n\\nWhat\\",
          "lines_count": 100
        },
        {
          "file_path": "doc/src/modules/solvers/solveset.rst",
          "start_line": 15,
          "end_line": 48,
          "content": "def test_imageset():\\n    ints = S.Integers\\n    assert imageset(x, x - 1, S.Naturals) is S.Naturals0\\n    assert imageset(x, x + 1, S.Naturals0) is S.Naturals\\n    assert imageset(x, abs(x), S.Naturals0) is S.Naturals0\\n    assert imageset(x, abs(x), S.Naturals) is S.Naturals\\n    assert imageset(x, abs(x), S.Integers) is S.Naturals0\\n    # issue 16878a\\n    r = symbols(\\",
          "lines_count": 34
        },
        {
          "file_path": "sympy/sets/tests/test_sets.py",
          "start_line": 90,
          "end_line": 155,
          "content": "def test_union():\\n    assert Union(Interval(1, 2), Interval(2, 3)) == Interval(1, 3)\\n    assert Union(Interval(1, 2), Interval(2, 3, True)) == Interval(1, 3)\\n    assert Union(Interval(1, 3), Interval(2, 4)) == Interval(1, 4)\\n    assert Union(Interval(1, 2), Interval(1, 3)) == Interval(1, 3)\\n    assert Union(Interval(1, 3), Interval(1, 2)) == Interval(1, 3)\\n    assert Union(Interval(1, 3, False, True), Interval(1, 2)) == \\\\\\n        Interval(1, 3, False, True)\\n    assert Union(Interval(1, 3), Interval(1, 2, False, True)) == Interval(1, 3)\\n    assert Union(Interval(1, 2, True), Interval(1, 3)) == Interval(1, 3)\\n    assert Union(Interval(1, 2, True), Interval(1, 3, True)) == \\\\\\n        Interval(1, 3, True)\\n    assert Union(Interval(1, 2, True), Interval(1, 3, True, True)) == \\\\\\n        Interval(1, 3, True, True)\\n    assert Union(Interval(1, 2, True, True), Interval(1, 3, True)) == \\\\\\n        Interval(1, 3, True)\\n    assert Union(Interval(1, 3), Interval(2, 3)) == Interval(1, 3)\\n    assert Union(Interval(1, 3, False, True), Interval(2, 3)) == \\\\\\n        Interval(1, 3)\\n    assert Union(Interval(1, 2, False, True), Interval(2, 3, True)) != \\\\\\n        Interval(1, 3)\\n    assert Union(Interval(1, 2), S.EmptySet) == Interval(1, 2)\\n    assert Union(S.EmptySet) == S.EmptySet\\n\\n    assert Union(Interval(0, 1), *[FiniteSet(1.0/n) for n in range(1, 10)]) == \\\\\\n        Interval(0, 1)\\n\\n    assert Interval(1, 2).union(Interval(2, 3)) == \\\\\\n        Interval(1, 2) + Interval(2, 3)\\n\\n    assert Interval(1, 2).union(Interval(2, 3)) == Interval(1, 3)\\n\\n    assert Union(Set()) == Set()\\n\\n    assert FiniteSet(1) + FiniteSet(2) + FiniteSet(3) == FiniteSet(1, 2, 3)\\n    assert FiniteSet(\\",
          "lines_count": 66
        },
        {
          "file_path": "sympy/sets/tests/test_sets.py",
          "start_line": 1,
          "end_line": 100,
          "content": ".. _solveset:\\n\\nSolveset\\n========\\n\\n.. module:: sympy.solvers.solveset\\n\\nThis is the official documentation of the ``solveset`` module in solvers.\\nIt contains the frequently asked questions about our new module to solve\\nequations.\\n\\nWhat\\",
          "lines_count": 100
        },
        {
          "file_path": "doc/src/modules/solvers/solveset.rst",
          "start_line": 15,
          "end_line": 48,
          "content": "def test_imageset():\\n    ints = S.Integers\\n    assert imageset(x, x - 1, S.Naturals) is S.Naturals0\\n    assert imageset(x, x + 1, S.Naturals0) is S.Naturals\\n    assert imageset(x, abs(x), S.Naturals0) is S.Naturals0\\n    assert imageset(x, abs(x), S.Naturals) is S.Naturals\\n    assert imageset(x, abs(x), S.Integers) is S.Naturals0\\n    # issue 16878a\\n    r = symbols(\\",
          "lines_count": 34
        },
        {
          "file_path": "sympy/sets/tests/test_sets.py",
          "start_line": 90,
          "end_line": 155,
          "content": "def test_union():\\n    assert Union(Interval(1, 2), Interval(2, 3)) == Interval(1, 3)\\n    assert Union(Interval(1, 2), Interval(2, 3, True)) == Interval(1, 3)\\n    assert Union(Interval(1, 3), Interval(2, 4)) == Interval(1, 4)\\n    assert Union(Interval(1, 2), Interval(1, 3)) == Interval(1, 3)\\n    assert Union(Interval(1, 3), Interval(1, 2)) == Interval(1, 3)\\n    assert Union(Interval(1, 3, False, True), Interval(1, 2)) == \\\\\\n        Interval(1, 3, False, True)\\n    assert Union(Interval(1, 3), Interval(1, 2, False, True)) == Interval(1, 3)\\n    assert Union(Interval(1, 2, True), Interval(1, 3)) == Interval(1, 3)\\n    assert Union(Interval(1, 2, True), Interval(1, 3, True)) == \\\\\\n        Interval(1, 3, True)\\n    assert Union(Interval(1, 2, True), Interval(1, 3, True, True)) == \\\\\\n        Interval(1, 3, True, True)\\n    assert Union(Interval(1, 2, True, True), Interval(1, 3, True)) == \\\\\\n        Interval(1, 3, True)\\n    assert Union(Interval(1, 3), Interval(2, 3)) == Interval(1, 3)\\n    assert Union(Interval(1, 3, False, True), Interval(2, 3)) == \\\\\\n        Interval(1, 3)\\n    assert Union(Interval(1, 2, False, True), Interval(2, 3, True)) != \\\\\\n        Interval(1, 3)\\n    assert Union(Interval(1, 2), S.EmptySet) == Interval(1, 2)\\n    assert Union(S.EmptySet) == S.EmptySet\\n\\n    assert Union(Interval(0, 1), *[FiniteSet(1.0/n) for n in range(1, 10)]) == \\\\\\n        Interval(0, 1)\\n\\n    assert Interval(1, 2).union(Interval(2, 3)) == \\\\\\n        Interval(1, 2) + Interval(2, 3)\\n\\n    assert Interval(1, 2).union(Interval(2, 3)) == Interval(1, 3)\\n\\n    assert Union(Set()) == Set()\\n\\n    assert FiniteSet(1) + FiniteSet(2) + FiniteSet(3) == FiniteSet(1, 2, 3)\\n    assert FiniteSet(\\",
          "lines_count": 66
        },
        {
          "file_path": "sympy/sets/tests/test_sets.py",
          "start_line": 1223,
          "end_line": 1384,
          "content": "Issue title:\\nIntersection should remove duplicates\\n\\nIssue description: \\n```python\\n>>> Intersection({1},{1},{x})\\nEmptySet()\\n>>> Intersection({1},{x})\\n{1}\\n```\\nThe answer should be `Piecewise(({1}, Eq(x, 1)), (S.EmptySet, True))` or remain unevaluated.\\n\\nThe routine should give the same answer if duplicates are present; my initial guess is that duplicates should just be removed at the outset of instantiation. Ordering them will produce canonical processing.\\n\\nIssue comments:\\n\\n\\nBug reproducing context:\\nFile: sympy/sets/tests/test_sets.py\\nLine number range: 261 - 313\\nContent:\\ndef test_intersect1():\\n    assert all(S.Integers.intersection(i) is i for i in\\n        (S.Naturals, S.Naturals0))\\n    assert all(i.intersection(S.Integers) is i for i in\\n        (S.Naturals, S.Naturals0))\\n    s =  S.Naturals0\\n    assert S.Naturals.intersection(s) is S.Naturals\\n    assert s.intersection(S.Naturals) is S.Naturals\\n    x = Symbol(\\",
          "lines_count": 162
        },
        {
          "file_path": "sympy/sets/sets.py",
          "start_line": 1971,
          "end_line": 2044,
          "content": "def simplify_intersection(args):\\n    \"\"\"\\n    Simplify an intersection using known rules\\n\\n    We first start with global rules like\\n    \\",
          "lines_count": 74
        },
        {
          "file_path": "sympy/sets/sets.py",
          "start_line": 1223,
          "end_line": 1384,
          "content": "class Intersection(Set, LatticeOp):\\n    \"\"\"\\n    Represents an intersection of sets as a :class:`Set`.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Intersection, Interval\\n    >>> Intersection(Interval(1, 3), Interval(2, 4))\\n    Interval(2, 3)\\n\\n    We often use the .intersect method\\n\\n    >>> Interval(1,3).intersect(Interval(2,4))\\n    Interval(2, 3)\\n\\n    See Also\\n    ========\\n\\n    Union\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Intersection_%28set_theory%29\\n    \"\"\"\\n    is_Intersection = True\\n\\n    @property\\n    def identity(self):\\n        return S.UniversalSet\\n\\n    @property\\n    def zero(self):\\n        return S.EmptySet\\n\\n    def __new__(cls, *args, **kwargs):\\n        evaluate = kwargs.get(\\",
          "lines_count": 162
        },
        {
          "file_path": "sympy/sets/sets.py",
          "start_line": 1971,
          "end_line": 2044,
          "content": "def simplify_intersection(args):\\n    \"\"\"\\n    Simplify an intersection using known rules\\n\\n    We first start with global rules like\\n    \\",
          "lines_count": 74
        },
        {
          "file_path": "sympy/functions/elementary/piecewise.py",
          "start_line": 67,
          "end_line": 308,
          "content": "class Piecewise(Function):\\n    \"\"\"\\n    Represents a piecewise function.\\n\\n    Usage:\\n\\n      Piecewise( (expr,cond), (expr,cond), ... )\\n        - Each argument is a 2-tuple defining an expression and condition\\n        - The conds are evaluated in turn returning the first that is True.\\n          If any of the evaluated conds are not determined explicitly False,\\n          e.g. x < 1, the function is returned in symbolic form.\\n        - If the function is evaluated at a place where all conditions are False,\\n          nan will be returned.\\n        - Pairs where the cond is explicitly False, will be removed.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Piecewise, log, ITE, piecewise_fold\\n    >>> from sympy.abc import x, y\\n    >>> f = x**2\\n    >>> g = log(x)\\n    >>> p = Piecewise((0, x < -1), (f, x <= 1), (g, True))\\n    >>> p.subs(x,1)\\n    1\\n    >>> p.subs(x,5)\\n    log(5)\\n\\n    Booleans can contain Piecewise elements:\\n\\n    >>> cond = (x < y).subs(x, Piecewise((2, x < 0), (3, True))); cond\\n    Piecewise((2, x < 0), (3, True)) < y\\n\\n    The folded version of this results in a Piecewise whose\\n    expressions are Booleans:\\n\\n    >>> folded_cond = piecewise_fold(cond); folded_cond\\n    Piecewise((2 < y, x < 0), (3 < y, True))\\n\\n    When a Boolean containing Piecewise (like cond) or a Piecewise\\n    with Boolean expressions (like folded_cond) is used as a condition,\\n    it is converted to an equivalent ITE object:\\n\\n    >>> Piecewise((1, folded_cond))\\n    Piecewise((1, ITE(x < 0, y > 2, y > 3)))\\n\\n    When a condition is an ITE, it will be converted to a simplified\\n    Boolean expression:\\n\\n    >>> piecewise_fold(_)\\n    Piecewise((1, ((x >= 0) | (y > 2)) & ((y > 3) | (x < 0))))\\n\\n    See Also\\n    ========\\n    piecewise_fold, ITE\\n    \"\"\"\\n\\n    nargs = None\\n    is_Piecewise = True\\n\\n    def __new__(cls, *args, **options):\\n        if len(args) == 0:\\n            raise TypeError(\"At least one (expr, cond) pair expected.\")\\n        # (Try to) sympify args first\\n        newargs = []\\n        for ec in args:\\n            # ec could be a ExprCondPair or a tuple\\n            pair = ExprCondPair(*getattr(ec, \\",
          "lines_count": 242
        },
        {
          "file_path": "sympy/functions/elementary/piecewise.py",
          "start_line": 738,
          "end_line": 801,
          "content": "    def _intervals(self, sym):\\n        \"\"\"Return a list of unique tuples, (a, b, e, i), where a and b\\n        are the lower and upper bounds in which the expression e of\\n        argument i in self is defined and a < b (when involving\\n        numbers) or a <= b when involving symbols.\\n\\n        If there are any relationals not involving sym, or any\\n        relational cannot be solved for sym, NotImplementedError is\\n        raised. The calling routine should have removed such\\n        relationals before calling this routine.\\n\\n        The evaluated conditions will be returned as ranges.\\n        Discontinuous ranges will be returned separately with\\n        identical expressions. The first condition that evaluates to\\n        True will be returned as the last tuple with a, b = -oo, oo.\\n        \"\"\"\\n        from sympy.solvers.inequalities import _solve_inequality\\n        from sympy.logic.boolalg import to_cnf, distribute_or_over_and\\n\\n        assert isinstance(self, Piecewise)\\n\\n        def _solve_relational(r):\\n            if sym not in r.free_symbols:\\n                nonsymfail(r)\\n            rv = _solve_inequality(r, sym)\\n            if isinstance(rv, Relational):\\n                free = rv.args[1].free_symbols\\n                if rv.args[0] != sym or sym in free:\\n                    raise NotImplementedError(filldedent(\\",
          "lines_count": 64
        },
        {
          "file_path": "sympy/sets/sets.py",
          "start_line": 1223,
          "end_line": 1384,
          "content": "class Intersection(Set, LatticeOp):\\n    \"\"\"\\n    Represents an intersection of sets as a :class:`Set`.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Intersection, Interval\\n    >>> Intersection(Interval(1, 3), Interval(2, 4))\\n    Interval(2, 3)\\n\\n    We often use the .intersect method\\n\\n    >>> Interval(1,3).intersect(Interval(2,4))\\n    Interval(2, 3)\\n\\n    See Also\\n    ========\\n\\n    Union\\n\\n    References\\n    ==========\\n\\n    .. [1] https://en.wikipedia.org/wiki/Intersection_%28set_theory%29\\n    \"\"\"\\n    is_Intersection = True\\n\\n    @property\\n    def identity(self):\\n        return S.UniversalSet\\n\\n    @property\\n    def zero(self):\\n        return S.EmptySet\\n\\n    def __new__(cls, *args, **kwargs):\\n        evaluate = kwargs.get(\\",
          "lines_count": 162
        },
        {
          "file_path": "sympy/sets/sets.py",
          "start_line": 1971,
          "end_line": 2044,
          "content": "def simplify_intersection(args):\\n    \"\"\"\\n    Simplify an intersection using known rules\\n\\n    We first start with global rules like\\n    \\",
          "lines_count": 74
        },
        {
          "file_path": "sympy/functions/elementary/piecewise.py",
          "start_line": 67,
          "end_line": 308,
          "content": "class Piecewise(Function):\\n    \"\"\"\\n    Represents a piecewise function.\\n\\n    Usage:\\n\\n      Piecewise( (expr,cond), (expr,cond), ... )\\n        - Each argument is a 2-tuple defining an expression and condition\\n        - The conds are evaluated in turn returning the first that is True.\\n          If any of the evaluated conds are not determined explicitly False,\\n          e.g. x < 1, the function is returned in symbolic form.\\n        - If the function is evaluated at a place where all conditions are False,\\n          nan will be returned.\\n        - Pairs where the cond is explicitly False, will be removed.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Piecewise, log, ITE, piecewise_fold\\n    >>> from sympy.abc import x, y\\n    >>> f = x**2\\n    >>> g = log(x)\\n    >>> p = Piecewise((0, x < -1), (f, x <= 1), (g, True))\\n    >>> p.subs(x,1)\\n    1\\n    >>> p.subs(x,5)\\n    log(5)\\n\\n    Booleans can contain Piecewise elements:\\n\\n    >>> cond = (x < y).subs(x, Piecewise((2, x < 0), (3, True))); cond\\n    Piecewise((2, x < 0), (3, True)) < y\\n\\n    The folded version of this results in a Piecewise whose\\n    expressions are Booleans:\\n\\n    >>> folded_cond = piecewise_fold(cond); folded_cond\\n    Piecewise((2 < y, x < 0), (3 < y, True))\\n\\n    When a Boolean containing Piecewise (like cond) or a Piecewise\\n    with Boolean expressions (like folded_cond) is used as a condition,\\n    it is converted to an equivalent ITE object:\\n\\n    >>> Piecewise((1, folded_cond))\\n    Piecewise((1, ITE(x < 0, y > 2, y > 3)))\\n\\n    When a condition is an ITE, it will be converted to a simplified\\n    Boolean expression:\\n\\n    >>> piecewise_fold(_)\\n    Piecewise((1, ((x >= 0) | (y > 2)) & ((y > 3) | (x < 0))))\\n\\n    See Also\\n    ========\\n    piecewise_fold, ITE\\n    \"\"\"\\n\\n    nargs = None\\n    is_Piecewise = True\\n\\n    def __new__(cls, *args, **options):\\n        if len(args) == 0:\\n            raise TypeError(\"At least one (expr, cond) pair expected.\")\\n        # (Try to) sympify args first\\n        newargs = []\\n        for ec in args:\\n            # ec could be a ExprCondPair or a tuple\\n            pair = ExprCondPair(*getattr(ec, \\",
          "lines_count": 242
        },
        {
          "file_path": "sympy/functions/elementary/piecewise.py",
          "start_line": 738,
          "end_line": 801,
          "content": "    def _intervals(self, sym):\\n        \"\"\"Return a list of unique tuples, (a, b, e, i), where a and b\\n        are the lower and upper bounds in which the expression e of\\n        argument i in self is defined and a < b (when involving\\n        numbers) or a <= b when involving symbols.\\n\\n        If there are any relationals not involving sym, or any\\n        relational cannot be solved for sym, NotImplementedError is\\n        raised. The calling routine should have removed such\\n        relationals before calling this routine.\\n\\n        The evaluated conditions will be returned as ranges.\\n        Discontinuous ranges will be returned separately with\\n        identical expressions. The first condition that evaluates to\\n        True will be returned as the last tuple with a, b = -oo, oo.\\n        \"\"\"\\n        from sympy.solvers.inequalities import _solve_inequality\\n        from sympy.logic.boolalg import to_cnf, distribute_or_over_and\\n\\n        assert isinstance(self, Piecewise)\\n\\n        def _solve_relational(r):\\n            if sym not in r.free_symbols:\\n                nonsymfail(r)\\n            rv = _solve_inequality(r, sym)\\n            if isinstance(rv, Relational):\\n                free = rv.args[1].free_symbols\\n                if rv.args[0] != sym or sym in free:\\n                    raise NotImplementedError(filldedent(\\",
          "lines_count": 64
        },
        {
          "file_path": "sympy/sets/handlers/intersection.py",
          "start_line": 10,
          "end_line": 433,
          "content": "@dispatch(ConditionSet, ConditionSet)\\ndef intersection_sets(a, b):\\n    return None\\n\\n@dispatch(ConditionSet, Set)\\ndef intersection_sets(a, b):\\n    return ConditionSet(a.sym, a.condition, Intersection(a.base_set, b))\\n\\n@dispatch(Naturals, Integers)\\ndef intersection_sets(a, b):\\n    return a\\n\\n@dispatch(Integers, Naturals)\\ndef intersection_sets(a, b):\\n    return b\\n\\n@dispatch(Naturals, Naturals)\\ndef intersection_sets(a, b):\\n    return a if a is S.Naturals else b\\n\\n@dispatch(Interval, Naturals)\\ndef intersection_sets(a, b):\\n    return intersection_sets(b, a)\\n\\n@dispatch(ComplexRegion, Set)\\ndef intersection_sets(self, other):\\n    if other.is_ComplexRegion:\\n        # self in rectangular form\\n        if (not self.polar) and (not other.polar):\\n            return ComplexRegion(Intersection(self.sets, other.sets))\\n\\n        # self in polar form\\n        elif self.polar and other.polar:\\n            r1, theta1 = self.a_interval, self.b_interval\\n            r2, theta2 = other.a_interval, other.b_interval\\n            new_r_interval = Intersection(r1, r2)\\n            new_theta_interval = Intersection(theta1, theta2)\\n\\n            # 0 and 2*Pi means the same\\n            if ((2*S.Pi in theta1 and S.Zero in theta2) or\\n               (2*S.Pi in theta2 and S.Zero in theta1)):\\n                new_theta_interval = Union(new_theta_interval,\\n                                           FiniteSet(0))\\n            return ComplexRegion(new_r_interval*new_theta_interval,\\n                                polar=True)\\n\\n\\n    if other.is_subset(S.Reals):\\n        new_interval = []\\n        x = symbols(\"x\", cls=Dummy, real=True)\\n\\n        # self in rectangular form\\n        if not self.polar:\\n            for element in self.psets:\\n                if S.Zero in element.args[1]:\\n                    new_interval.append(element.args[0])\\n            new_interval = Union(*new_interval)\\n            return Intersection(new_interval, other)\\n\\n        # self in polar form\\n        elif self.polar:\\n            for element in self.psets:\\n                if S.Zero in element.args[1]:\\n                    new_interval.append(element.args[0])\\n                if S.Pi in element.args[1]:\\n                    new_interval.append(ImageSet(Lambda(x, -x), element.args[0]))\\n                if S.Zero in element.args[0]:\\n                    new_interval.append(FiniteSet(0))\\n            new_interval = Union(*new_interval)\\n            return Intersection(new_interval, other)\\n\\n@dispatch(Integers, Reals)\\ndef intersection_sets(a, b):\\n    return a\\n\\n@dispatch(Range, Interval)\\ndef intersection_sets(a, b):\\n    from sympy.functions.elementary.integers import floor, ceiling\\n    from sympy.functions.elementary.miscellaneous import Min, Max\\n    if not all(i.is_number for i in b.args[:2]):\\n        return\\n\\n    # In case of null Range, return an EmptySet.\\n    if a.size == 0:\\n        return S.EmptySet\\n\\n    # trim down to self\\",
          "lines_count": 424
        },
        {
          "file_path": "sympy/sets/sets.py",
          "start_line": 38,
          "end_line": 605,
          "content": "class Set(Basic):\\n    \"\"\"\\n    The base class for any kind of set.\\n\\n    This is not meant to be used directly as a container of items. It does not\\n    behave like the builtin ``set``; see :class:`FiniteSet` for that.\\n\\n    Real intervals are represented by the :class:`Interval` class and unions of\\n    sets by the :class:`Union` class. The empty set is represented by the\\n    :class:`EmptySet` class and available as a singleton as ``S.EmptySet``.\\n    \"\"\"\\n    is_number = False\\n    is_iterable = False\\n    is_interval = False\\n\\n    is_FiniteSet = False\\n    is_Interval = False\\n    is_ProductSet = False\\n    is_Union = False\\n    is_Intersection = None\\n    is_EmptySet = None\\n    is_UniversalSet = None\\n    is_Complement = None\\n    is_ComplexRegion = False\\n\\n    @staticmethod\\n    def _infimum_key(expr):\\n        \"\"\"\\n        Return infimum (if possible) else S.Infinity.\\n        \"\"\"\\n        try:\\n            infimum = expr.inf\\n            assert infimum.is_comparable\\n        except (NotImplementedError,\\n                AttributeError, AssertionError, ValueError):\\n            infimum = S.Infinity\\n        return infimum\\n\\n    def union(self, other):\\n        \"\"\"\\n        Returns the union of \\",
          "lines_count": 568
        },
        {
          "file_path": "sympy/sets/conditionset.py",
          "start_line": 17,
          "end_line": 247,
          "content": "class ConditionSet(Set):\\n    \"\"\"\\n    Set of elements which satisfies a given condition.\\n\\n    {x | condition(x) is True for x in S}\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Symbol, S, ConditionSet, pi, Eq, sin, Interval\\n    >>> from sympy.abc import x, y, z\\n\\n    >>> sin_sols = ConditionSet(x, Eq(sin(x), 0), Interval(0, 2*pi))\\n    >>> 2*pi in sin_sols\\n    True\\n    >>> pi/2 in sin_sols\\n    False\\n    >>> 3*pi in sin_sols\\n    False\\n    >>> 5 in ConditionSet(x, x**2 > 4, S.Reals)\\n    True\\n\\n    If the value is not in the base set, the result is false:\\n\\n    >>> 5 in ConditionSet(x, x**2 > 4, Interval(2, 4))\\n    False\\n\\n    Notes\\n    =====\\n\\n    Symbols with assumptions should be avoided or else the\\n    condition may evaluate without consideration of the set:\\n\\n    >>> n = Symbol(\\",
          "lines_count": 231
        },
        {
          "file_path": "sympy/sets/handlers/intersection.py",
          "start_line": 10,
          "end_line": 433,
          "content": "@dispatch(ConditionSet, ConditionSet)\\ndef intersection_sets(a, b):\\n    return None\\n\\n@dispatch(ConditionSet, Set)\\ndef intersection_sets(a, b):\\n    return ConditionSet(a.sym, a.condition, Intersection(a.base_set, b))\\n\\n@dispatch(Naturals, Integers)\\ndef intersection_sets(a, b):\\n    return a\\n\\n@dispatch(Integers, Naturals)\\ndef intersection_sets(a, b):\\n    return b\\n\\n@dispatch(Naturals, Naturals)\\ndef intersection_sets(a, b):\\n    return a if a is S.Naturals else b\\n\\n@dispatch(Interval, Naturals)\\ndef intersection_sets(a, b):\\n    return intersection_sets(b, a)\\n\\n@dispatch(ComplexRegion, Set)\\ndef intersection_sets(self, other):\\n    if other.is_ComplexRegion:\\n        # self in rectangular form\\n        if (not self.polar) and (not other.polar):\\n            return ComplexRegion(Intersection(self.sets, other.sets))\\n\\n        # self in polar form\\n        elif self.polar and other.polar:\\n            r1, theta1 = self.a_interval, self.b_interval\\n            r2, theta2 = other.a_interval, other.b_interval\\n            new_r_interval = Intersection(r1, r2)\\n            new_theta_interval = Intersection(theta1, theta2)\\n\\n            # 0 and 2*Pi means the same\\n            if ((2*S.Pi in theta1 and S.Zero in theta2) or\\n               (2*S.Pi in theta2 and S.Zero in theta1)):\\n                new_theta_interval = Union(new_theta_interval,\\n                                           FiniteSet(0))\\n            return ComplexRegion(new_r_interval*new_theta_interval,\\n                                polar=True)\\n\\n\\n    if other.is_subset(S.Reals):\\n        new_interval = []\\n        x = symbols(\"x\", cls=Dummy, real=True)\\n\\n        # self in rectangular form\\n        if not self.polar:\\n            for element in self.psets:\\n                if S.Zero in element.args[1]:\\n                    new_interval.append(element.args[0])\\n            new_interval = Union(*new_interval)\\n            return Intersection(new_interval, other)\\n\\n        # self in polar form\\n        elif self.polar:\\n            for element in self.psets:\\n                if S.Zero in element.args[1]:\\n                    new_interval.append(element.args[0])\\n                if S.Pi in element.args[1]:\\n                    new_interval.append(ImageSet(Lambda(x, -x), element.args[0]))\\n                if S.Zero in element.args[0]:\\n                    new_interval.append(FiniteSet(0))\\n            new_interval = Union(*new_interval)\\n            return Intersection(new_interval, other)\\n\\n@dispatch(Integers, Reals)\\ndef intersection_sets(a, b):\\n    return a\\n\\n@dispatch(Range, Interval)\\ndef intersection_sets(a, b):\\n    from sympy.functions.elementary.integers import floor, ceiling\\n    from sympy.functions.elementary.miscellaneous import Min, Max\\n    if not all(i.is_number for i in b.args[:2]):\\n        return\\n\\n    # In case of null Range, return an EmptySet.\\n    if a.size == 0:\\n        return S.EmptySet\\n\\n    # trim down to self\\",
          "lines_count": 424
        },
        {
          "file_path": "sympy/sets/sets.py",
          "start_line": 38,
          "end_line": 605,
          "content": "class Set(Basic):\\n    \"\"\"\\n    The base class for any kind of set.\\n\\n    This is not meant to be used directly as a container of items. It does not\\n    behave like the builtin ``set``; see :class:`FiniteSet` for that.\\n\\n    Real intervals are represented by the :class:`Interval` class and unions of\\n    sets by the :class:`Union` class. The empty set is represented by the\\n    :class:`EmptySet` class and available as a singleton as ``S.EmptySet``.\\n    \"\"\"\\n    is_number = False\\n    is_iterable = False\\n    is_interval = False\\n\\n    is_FiniteSet = False\\n    is_Interval = False\\n    is_ProductSet = False\\n    is_Union = False\\n    is_Intersection = None\\n    is_EmptySet = None\\n    is_UniversalSet = None\\n    is_Complement = None\\n    is_ComplexRegion = False\\n\\n    @staticmethod\\n    def _infimum_key(expr):\\n        \"\"\"\\n        Return infimum (if possible) else S.Infinity.\\n        \"\"\"\\n        try:\\n            infimum = expr.inf\\n            assert infimum.is_comparable\\n        except (NotImplementedError,\\n                AttributeError, AssertionError, ValueError):\\n            infimum = S.Infinity\\n        return infimum\\n\\n    def union(self, other):\\n        \"\"\"\\n        Returns the union of \\",
          "lines_count": 568
        },
        {
          "file_path": "sympy/sets/conditionset.py",
          "start_line": 17,
          "end_line": 247,
          "content": "class ConditionSet(Set):\\n    \"\"\"\\n    Set of elements which satisfies a given condition.\\n\\n    {x | condition(x) is True for x in S}\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Symbol, S, ConditionSet, pi, Eq, sin, Interval\\n    >>> from sympy.abc import x, y, z\\n\\n    >>> sin_sols = ConditionSet(x, Eq(sin(x), 0), Interval(0, 2*pi))\\n    >>> 2*pi in sin_sols\\n    True\\n    >>> pi/2 in sin_sols\\n    False\\n    >>> 3*pi in sin_sols\\n    False\\n    >>> 5 in ConditionSet(x, x**2 > 4, S.Reals)\\n    True\\n\\n    If the value is not in the base set, the result is false:\\n\\n    >>> 5 in ConditionSet(x, x**2 > 4, Interval(2, 4))\\n    False\\n\\n    Notes\\n    =====\\n\\n    Symbols with assumptions should be avoided or else the\\n    condition may evaluate without consideration of the set:\\n\\n    >>> n = Symbol(\\",
          "lines_count": 231
        },
        {
          "file_path": "sympy/functions/elementary/piecewise.py",
          "start_line": 67,
          "end_line": 167,
          "content": "class Piecewise(Function):\\n    \"\"\"\\n    Represents a piecewise function.\\n\\n    Usage:\\n\\n      Piecewise( (expr,cond), (expr,cond), ... )\\n        - Each argument is a 2-tuple defining an expression and condition\\n        - The conds are evaluated in turn returning the first that is True.\\n          If any of the evaluated conds are not determined explicitly False,\\n          e.g. x < 1, the function is returned in symbolic form.\\n        - If the function is evaluated at a place where all conditions are False,\\n          nan will be returned.\\n        - Pairs where the cond is explicitly False, will be removed.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Piecewise, log, ITE, piecewise_fold\\n    >>> from sympy.abc import x, y\\n    >>> f = x**2\\n    >>> g = log(x)\\n    >>> p = Piecewise((0, x < -1), (f, x <= 1), (g, True))\\n    >>> p.subs(x,1)\\n    1\\n    >>> p.subs(x,5)\\n    log(5)\\n\\n    Booleans can contain Piecewise elements:\\n\\n    >>> cond = (x < y).subs(x, Piecewise((2, x < 0), (3, True))); cond\\n    Piecewise((2, x < 0), (3, True)) < y\\n\\n    The folded version of this results in a Piecewise whose\\n    expressions are Booleans:\\n\\n    >>> folded_cond = piecewise_fold(cond); folded_cond\\n    Piecewise((2 < y, x < 0), (3 < y, True))\\n\\n    When a Boolean containing Piecewise (like cond) or a Piecewise\\n    with Boolean expressions (like folded_cond) is used as a condition,\\n    it is converted to an equivalent ITE object:\\n\\n    >>> Piecewise((1, folded_cond))\\n    Piecewise((1, ITE(x < 0, y > 2, y > 3)))\\n\\n    When a condition is an ITE, it will be converted to a simplified\\n    Boolean expression:\\n\\n    >>> piecewise_fold(_)\\n    Piecewise((1, ((x >= 0) | (y > 2)) & ((y > 3) | (x < 0))))\\n\\n    See Also\\n    ========\\n    piecewise_fold, ITE\\n    \"\"\"\\n\\n    nargs = None\\n    is_Piecewise = True\\n\\n    def __new__(cls, *args, **options):\\n        if len(args) == 0:\\n            raise TypeError(\"At least one (expr, cond) pair expected.\")\\n        # (Try to) sympify args first\\n        newargs = []\\n        for ec in args:\\n            # ec could be a ExprCondPair or a tuple\\n            pair = ExprCondPair(*getattr(ec, \\",
          "lines_count": 101
        },
        {
          "file_path": "sympy/sets/handlers/intersection.py",
          "start_line": 10,
          "end_line": 433,
          "content": "@dispatch(ConditionSet, ConditionSet)\\ndef intersection_sets(a, b):\\n    return None\\n\\n@dispatch(ConditionSet, Set)\\ndef intersection_sets(a, b):\\n    return ConditionSet(a.sym, a.condition, Intersection(a.base_set, b))\\n\\n@dispatch(Naturals, Integers)\\ndef intersection_sets(a, b):\\n    return a\\n\\n@dispatch(Integers, Naturals)\\ndef intersection_sets(a, b):\\n    return b\\n\\n@dispatch(Naturals, Naturals)\\ndef intersection_sets(a, b):\\n    return a if a is S.Naturals else b\\n\\n@dispatch(Interval, Naturals)\\ndef intersection_sets(a, b):\\n    return intersection_sets(b, a)\\n\\n@dispatch(ComplexRegion, Set)\\ndef intersection_sets(self, other):\\n    if other.is_ComplexRegion:\\n        # self in rectangular form\\n        if (not self.polar) and (not other.polar):\\n            return ComplexRegion(Intersection(self.sets, other.sets))\\n\\n        # self in polar form\\n        elif self.polar and other.polar:\\n            r1, theta1 = self.a_interval, self.b_interval\\n            r2, theta2 = other.a_interval, other.b_interval\\n            new_r_interval = Intersection(r1, r2)\\n            new_theta_interval = Intersection(theta1, theta2)\\n\\n            # 0 and 2*Pi means the same\\n            if ((2*S.Pi in theta1 and S.Zero in theta2) or\\n               (2*S.Pi in theta2 and S.Zero in theta1)):\\n                new_theta_interval = Union(new_theta_interval,\\n                                           FiniteSet(0))\\n            return ComplexRegion(new_r_interval*new_theta_interval,\\n                                polar=True)\\n\\n\\n    if other.is_subset(S.Reals):\\n        new_interval = []\\n        x = symbols(\"x\", cls=Dummy, real=True)\\n\\n        # self in rectangular form\\n        if not self.polar:\\n            for element in self.psets:\\n                if S.Zero in element.args[1]:\\n                    new_interval.append(element.args[0])\\n            new_interval = Union(*new_interval)\\n            return Intersection(new_interval, other)\\n\\n        # self in polar form\\n        elif self.polar:\\n            for element in self.psets:\\n                if S.Zero in element.args[1]:\\n                    new_interval.append(element.args[0])\\n                if S.Pi in element.args[1]:\\n                    new_interval.append(ImageSet(Lambda(x, -x), element.args[0]))\\n                if S.Zero in element.args[0]:\\n                    new_interval.append(FiniteSet(0))\\n            new_interval = Union(*new_interval)\\n            return Intersection(new_interval, other)\\n\\n@dispatch(Integers, Reals)\\ndef intersection_sets(a, b):\\n    return a\\n\\n@dispatch(Range, Interval)\\ndef intersection_sets(a, b):\\n    from sympy.functions.elementary.integers import floor, ceiling\\n    from sympy.functions.elementary.miscellaneous import Min, Max\\n    if not all(i.is_number for i in b.args[:2]):\\n        return\\n\\n    # In case of null Range, return an EmptySet.\\n    if a.size == 0:\\n        return S.EmptySet\\n\\n    # trim down to self\\",
          "lines_count": 424
        },
        {
          "file_path": "sympy/sets/sets.py",
          "start_line": 38,
          "end_line": 605,
          "content": "class Set(Basic):\\n    \"\"\"\\n    The base class for any kind of set.\\n\\n    This is not meant to be used directly as a container of items. It does not\\n    behave like the builtin ``set``; see :class:`FiniteSet` for that.\\n\\n    Real intervals are represented by the :class:`Interval` class and unions of\\n    sets by the :class:`Union` class. The empty set is represented by the\\n    :class:`EmptySet` class and available as a singleton as ``S.EmptySet``.\\n    \"\"\"\\n    is_number = False\\n    is_iterable = False\\n    is_interval = False\\n\\n    is_FiniteSet = False\\n    is_Interval = False\\n    is_ProductSet = False\\n    is_Union = False\\n    is_Intersection = None\\n    is_EmptySet = None\\n    is_UniversalSet = None\\n    is_Complement = None\\n    is_ComplexRegion = False\\n\\n    @staticmethod\\n    def _infimum_key(expr):\\n        \"\"\"\\n        Return infimum (if possible) else S.Infinity.\\n        \"\"\"\\n        try:\\n            infimum = expr.inf\\n            assert infimum.is_comparable\\n        except (NotImplementedError,\\n                AttributeError, AssertionError, ValueError):\\n            infimum = S.Infinity\\n        return infimum\\n\\n    def union(self, other):\\n        \"\"\"\\n        Returns the union of \\",
          "lines_count": 568
        },
        {
          "file_path": "sympy/sets/conditionset.py",
          "start_line": 17,
          "end_line": 247,
          "content": "class ConditionSet(Set):\\n    \"\"\"\\n    Set of elements which satisfies a given condition.\\n\\n    {x | condition(x) is True for x in S}\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Symbol, S, ConditionSet, pi, Eq, sin, Interval\\n    >>> from sympy.abc import x, y, z\\n\\n    >>> sin_sols = ConditionSet(x, Eq(sin(x), 0), Interval(0, 2*pi))\\n    >>> 2*pi in sin_sols\\n    True\\n    >>> pi/2 in sin_sols\\n    False\\n    >>> 3*pi in sin_sols\\n    False\\n    >>> 5 in ConditionSet(x, x**2 > 4, S.Reals)\\n    True\\n\\n    If the value is not in the base set, the result is false:\\n\\n    >>> 5 in ConditionSet(x, x**2 > 4, Interval(2, 4))\\n    False\\n\\n    Notes\\n    =====\\n\\n    Symbols with assumptions should be avoided or else the\\n    condition may evaluate without consideration of the set:\\n\\n    >>> n = Symbol(\\",
          "lines_count": 231
        },
        {
          "file_path": "sympy/functions/elementary/piecewise.py",
          "start_line": 67,
          "end_line": 167,
          "content": "class Piecewise(Function):\\n    \"\"\"\\n    Represents a piecewise function.\\n\\n    Usage:\\n\\n      Piecewise( (expr,cond), (expr,cond), ... )\\n        - Each argument is a 2-tuple defining an expression and condition\\n        - The conds are evaluated in turn returning the first that is True.\\n          If any of the evaluated conds are not determined explicitly False,\\n          e.g. x < 1, the function is returned in symbolic form.\\n        - If the function is evaluated at a place where all conditions are False,\\n          nan will be returned.\\n        - Pairs where the cond is explicitly False, will be removed.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import Piecewise, log, ITE, piecewise_fold\\n    >>> from sympy.abc import x, y\\n    >>> f = x**2\\n    >>> g = log(x)\\n    >>> p = Piecewise((0, x < -1), (f, x <= 1), (g, True))\\n    >>> p.subs(x,1)\\n    1\\n    >>> p.subs(x,5)\\n    log(5)\\n\\n    Booleans can contain Piecewise elements:\\n\\n    >>> cond = (x < y).subs(x, Piecewise((2, x < 0), (3, True))); cond\\n    Piecewise((2, x < 0), (3, True)) < y\\n\\n    The folded version of this results in a Piecewise whose\\n    expressions are Booleans:\\n\\n    >>> folded_cond = piecewise_fold(cond); folded_cond\\n    Piecewise((2 < y, x < 0), (3 < y, True))\\n\\n    When a Boolean containing Piecewise (like cond) or a Piecewise\\n    with Boolean expressions (like folded_cond) is used as a condition,\\n    it is converted to an equivalent ITE object:\\n\\n    >>> Piecewise((1, folded_cond))\\n    Piecewise((1, ITE(x < 0, y > 2, y > 3)))\\n\\n    When a condition is an ITE, it will be converted to a simplified\\n    Boolean expression:\\n\\n    >>> piecewise_fold(_)\\n    Piecewise((1, ((x >= 0) | (y > 2)) & ((y > 3) | (x < 0))))\\n\\n    See Also\\n    ========\\n    piecewise_fold, ITE\\n    \"\"\"\\n\\n    nargs = None\\n    is_Piecewise = True\\n\\n    def __new__(cls, *args, **options):\\n        if len(args) == 0:\\n            raise TypeError(\"At least one (expr, cond) pair expected.\")\\n        # (Try to) sympify args first\\n        newargs = []\\n        for ec in args:\\n            # ec could be a ExprCondPair or a tuple\\n            pair = ExprCondPair(*getattr(ec, \\",
          "lines_count": 101
        }
      ],
      "test_results": {
        "overall_success": false,
        "issue_resolved": false
      },
      "gold_patch_analysis": {
        "modified_files": [
          "sympy/sets/sets.py"
        ],
        "context_files": [
          "sympy/sets/sets.py",
          "doc/src/modules/solvers/solveset.rst",
          "sympy/sets/tests/test_sets.py",
          "sympy/sets/conditionset.py",
          "sympy/sets/handlers/intersection.py",
          "sympy/functions/elementary/piecewise.py"
        ],
        "file_coverage": 1.0,
        "covered_files": [
          "sympy/sets/sets.py"
        ],
        "missed_files": [],
        "total_code_blocks": 1,
        "covered_code_blocks": 1,
        "code_block_coverage": 1.0,
        "code_blocks_detail": [
          {
            "file_path": "sympy/sets/sets.py",
            "old_start_line": 1260,
            "new_start_line": 1260,
            "hunk_content": "         evaluate = kwargs.get('evaluate', global_evaluate[0])\n \n         # flatten inputs to merge intersections and iterables\n-        args = _sympify(args)\n+        args = list(ordered(set(_sympify(args))))\n \n         # Reduce sets using known rules\n         if evaluate:\n",
            "added_lines": [
              "+        args = list(ordered(set(_sympify(args))))"
            ],
            "removed_lines": [
              "-        args = _sympify(args)"
            ],
            "new_end_line": 1267,
            "enclosing_functions": [],
            "enclosing_classes": []
          }
        ],
        "function_coverage": {
          "total_functions": 0,
          "covered_functions": 0,
          "coverage_rate": 0,
          "patch_functions": [],
          "context_functions": [
            {
              "name": "test_imageset",
              "line": 15,
              "type": "function",
              "file": "doc/src/modules/solvers/solveset.rst"
            },
            {
              "name": "test_union",
              "line": 90,
              "type": "function",
              "file": "sympy/sets/tests/test_sets.py"
            },
            {
              "name": "test_imageset",
              "line": 15,
              "type": "function",
              "file": "doc/src/modules/solvers/solveset.rst"
            },
            {
              "name": "test_union",
              "line": 90,
              "type": "function",
              "file": "sympy/sets/tests/test_sets.py"
            },
            {
              "name": "simplify_intersection",
              "line": 1971,
              "type": "function",
              "file": "sympy/sets/sets.py"
            },
            {
              "name": "simplify_intersection",
              "line": 1971,
              "type": "function",
              "file": "sympy/sets/sets.py"
            },
            {
              "name": "_intervals",
              "line": 738,
              "type": "function",
              "file": "sympy/functions/elementary/piecewise.py"
            },
            {
              "name": "simplify_intersection",
              "line": 1971,
              "type": "function",
              "file": "sympy/sets/sets.py"
            },
            {
              "name": "_intervals",
              "line": 738,
              "type": "function",
              "file": "sympy/functions/elementary/piecewise.py"
            }
          ]
        },
        "class_coverage": {
          "total_classes": 0,
          "covered_classes": 0,
          "coverage_rate": 0,
          "patch_classes": [],
          "context_classes": [
            {
              "name": "Intersection",
              "line": 1223,
              "type": "class",
              "file": "sympy/sets/sets.py"
            },
            {
              "name": "Piecewise",
              "line": 67,
              "type": "class",
              "file": "sympy/functions/elementary/piecewise.py"
            },
            {
              "name": "Intersection",
              "line": 1223,
              "type": "class",
              "file": "sympy/sets/sets.py"
            },
            {
              "name": "Piecewise",
              "line": 67,
              "type": "class",
              "file": "sympy/functions/elementary/piecewise.py"
            },
            {
              "name": "Set",
              "line": 38,
              "type": "class",
              "file": "sympy/sets/sets.py"
            },
            {
              "name": "ConditionSet",
              "line": 17,
              "type": "class",
              "file": "sympy/sets/conditionset.py"
            },
            {
              "name": "Set",
              "line": 38,
              "type": "class",
              "file": "sympy/sets/sets.py"
            },
            {
              "name": "ConditionSet",
              "line": 17,
              "type": "class",
              "file": "sympy/sets/conditionset.py"
            },
            {
              "name": "Piecewise",
              "line": 67,
              "type": "class",
              "file": "sympy/functions/elementary/piecewise.py"
            },
            {
              "name": "Set",
              "line": 38,
              "type": "class",
              "file": "sympy/sets/sets.py"
            },
            {
              "name": "ConditionSet",
              "line": 17,
              "type": "class",
              "file": "sympy/sets/conditionset.py"
            },
            {
              "name": "Piecewise",
              "line": 67,
              "type": "class",
              "file": "sympy/functions/elementary/piecewise.py"
            }
          ]
        }
      }
    },
    {
      "instance_id": "django__django-15814",
      "project": "django",
      "total_contexts_found": 42,
      "unique_files_accessed": 7,
      "contexts_detail": [
        {
          "file_path": "tests/auth_tests/models/proxy.py",
          "start_line": 5,
          "end_line": 17,
          "content": "class Concrete(models.Model):\\n    pass\\n\\n\\nclass Proxy(Concrete):\\n    class Meta:\\n        proxy = True\\n        permissions = ((\"display_proxys\", \"May display proxys information\"),)\\n\\n\\nclass UserProxy(User):\\n    class Meta:\\n        proxy = True\\n",
          "lines_count": 13
        },
        {
          "file_path": "tests/auth_tests/test_models.py",
          "start_line": 516,
          "end_line": 522,
          "content": "    def test_create_user(self):\\n        User.objects.create_user(\"JohnDoe\")\\n        self.assertEqual(self.signals_count, 1)\\n\\n    def test_create_superuser(self):\\n        User.objects.create_superuser(\"JohnDoe\", \"mail@example.com\", \"1\")\\n        self.assertEqual(self.signals_count, 1)\\n",
          "lines_count": 7
        },
        {
          "file_path": "tests/auth_tests/test_models.py",
          "start_line": 520,
          "end_line": 522,
          "content": "    def test_create_superuser(self):\\n        User.objects.create_superuser(\"JohnDoe\", \"mail@example.com\", \"1\")\\n        self.assertEqual(self.signals_count, 1)\\n",
          "lines_count": 3
        },
        {
          "file_path": "tests/auth_tests/models/proxy.py",
          "start_line": 5,
          "end_line": 17,
          "content": "class Concrete(models.Model):\\n    pass\\n\\n\\nclass Proxy(Concrete):\\n    class Meta:\\n        proxy = True\\n        permissions = ((\"display_proxys\", \"May display proxys information\"),)\\n\\n\\nclass UserProxy(User):\\n    class Meta:\\n        proxy = True\\n",
          "lines_count": 13
        },
        {
          "file_path": "tests/auth_tests/test_models.py",
          "start_line": 516,
          "end_line": 522,
          "content": "    def test_create_user(self):\\n        User.objects.create_user(\"JohnDoe\")\\n        self.assertEqual(self.signals_count, 1)\\n\\n    def test_create_superuser(self):\\n        User.objects.create_superuser(\"JohnDoe\", \"mail@example.com\", \"1\")\\n        self.assertEqual(self.signals_count, 1)\\n",
          "lines_count": 7
        },
        {
          "file_path": "tests/auth_tests/test_models.py",
          "start_line": 520,
          "end_line": 522,
          "content": "    def test_create_superuser(self):\\n        User.objects.create_superuser(\"JohnDoe\", \"mail@example.com\", \"1\")\\n        self.assertEqual(self.signals_count, 1)\\n",
          "lines_count": 3
        },
        {
          "file_path": "tests/select_related_onetoone/tests.py",
          "start_line": 24,
          "end_line": 260,
          "content": "class ReverseSelectRelatedTestCase(TestCase):\\n    @classmethod\\n    def setUpTestData(cls):\\n        user = User.objects.create(username=\"test\")\\n        UserProfile.objects.create(user=user, state=\"KS\", city=\"Lawrence\")\\n        results = UserStatResult.objects.create(results=\"first results\")\\n        userstat = UserStat.objects.create(user=user, posts=150, results=results)\\n        StatDetails.objects.create(base_stats=userstat, comments=259)\\n\\n        user2 = User.objects.create(username=\"bob\")\\n        results2 = UserStatResult.objects.create(results=\"moar results\")\\n        advstat = AdvancedUserStat.objects.create(\\n            user=user2, posts=200, karma=5, results=results2\\n        )\\n        StatDetails.objects.create(base_stats=advstat, comments=250)\\n        p1 = Parent1(name1=\"Only Parent1\")\\n        p1.save()\\n        c1 = Child1(name1=\"Child1 Parent1\", name2=\"Child1 Parent2\", value=1)\\n        c1.save()\\n        p2 = Parent2(name2=\"Child2 Parent2\")\\n        p2.save()\\n        c2 = Child2(name1=\"Child2 Parent1\", parent2=p2, value=2)\\n        c2.save()\\n\\n    def test_basic(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\"userprofile\").get(username=\"test\")\\n            self.assertEqual(u.userprofile.state, \"KS\")\\n\\n    def test_follow_next_level(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\"userstat__results\").get(username=\"test\")\\n            self.assertEqual(u.userstat.posts, 150)\\n            self.assertEqual(u.userstat.results.results, \"first results\")\\n\\n    def test_follow_two(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\"userprofile\", \"userstat\").get(\\n                username=\"test\"\\n            )\\n            self.assertEqual(u.userprofile.state, \"KS\")\\n            self.assertEqual(u.userstat.posts, 150)\\n\\n    def test_follow_two_next_level(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\\n                \"userstat__results\", \"userstat__statdetails\"\\n            ).get(username=\"test\")\\n            self.assertEqual(u.userstat.results.results, \"first results\")\\n            self.assertEqual(u.userstat.statdetails.comments, 259)\\n\\n    def test_forward_and_back(self):\\n        with self.assertNumQueries(1):\\n            stat = UserStat.objects.select_related(\"user__userprofile\").get(\\n                user__username=\"test\"\\n            )\\n            self.assertEqual(stat.user.userprofile.state, \"KS\")\\n            self.assertEqual(stat.user.userstat.posts, 150)\\n\\n    def test_back_and_forward(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\"userstat\").get(username=\"test\")\\n            self.assertEqual(u.userstat.user.username, \"test\")\\n\\n    def test_not_followed_by_default(self):\\n        with self.assertNumQueries(2):\\n            u = User.objects.select_related().get(username=\"test\")\\n            self.assertEqual(u.userstat.posts, 150)\\n\\n    def test_follow_from_child_class(self):\\n        with self.assertNumQueries(1):\\n            stat = AdvancedUserStat.objects.select_related(\"user\", \"statdetails\").get(\\n                posts=200\\n            )\\n            self.assertEqual(stat.statdetails.comments, 250)\\n            self.assertEqual(stat.user.username, \"bob\")\\n\\n    def test_follow_inheritance(self):\\n        with self.assertNumQueries(1):\\n            stat = UserStat.objects.select_related(\"user\", \"advanceduserstat\").get(\\n                posts=200\\n            )\\n            self.assertEqual(stat.advanceduserstat.posts, 200)\\n            self.assertEqual(stat.user.username, \"bob\")\\n        with self.assertNumQueries(0):\\n            self.assertEqual(stat.advanceduserstat.user.username, \"bob\")\\n\\n    def test_nullable_relation(self):\\n        im = Image.objects.create(name=\"imag1\")\\n        p1 = Product.objects.create(name=\"Django Plushie\", image=im)\\n        p2 = Product.objects.create(name=\"Talking Django Plushie\")\\n\\n        with self.assertNumQueries(1):\\n            result = sorted(\\n                Product.objects.select_related(\"image\"), key=lambda x: x.name\\n            )\\n            self.assertEqual(\\n                [p.name for p in result], [\"Django Plushie\", \"Talking Django Plushie\"]\\n            )\\n\\n            self.assertEqual(p1.image, im)\\n            # Check for ticket #13839\\n            self.assertIsNone(p2.image)\\n\\n    def test_missing_reverse(self):\\n        \"\"\"\\n        Ticket #13839: select_related() should NOT cache None\\n        for missing objects on a reverse 1-1 relation.\\n        \"\"\"\\n        with self.assertNumQueries(1):\\n            user = User.objects.select_related(\"userprofile\").get(username=\"bob\")\\n            with self.assertRaises(UserProfile.DoesNotExist):\\n                user.userprofile\\n\\n    def test_nullable_missing_reverse(self):\\n        \"\"\"\\n        Ticket #13839: select_related() should NOT cache None\\n        for missing objects on a reverse 0-1 relation.\\n        \"\"\"\\n        Image.objects.create(name=\"imag1\")\\n\\n        with self.assertNumQueries(1):\\n            image = Image.objects.select_related(\"product\").get()\\n            with self.assertRaises(Product.DoesNotExist):\\n                image.product\\n\\n    def test_parent_only(self):\\n        with self.assertNumQueries(1):\\n            p = Parent1.objects.select_related(\"child1\").get(name1=\"Only Parent1\")\\n        with self.assertNumQueries(0):\\n            with self.assertRaises(Child1.DoesNotExist):\\n                p.child1\\n\\n    def test_multiple_subclass(self):\\n        with self.assertNumQueries(1):\\n            p = Parent1.objects.select_related(\"child1\").get(name1=\"Child1 Parent1\")\\n            self.assertEqual(p.child1.name2, \"Child1 Parent2\")\\n\\n    def test_onetoone_with_subclass(self):\\n        with self.assertNumQueries(1):\\n            p = Parent2.objects.select_related(\"child2\").get(name2=\"Child2 Parent2\")\\n            self.assertEqual(p.child2.name1, \"Child2 Parent1\")\\n\\n    def test_onetoone_with_two_subclasses(self):\\n        with self.assertNumQueries(1):\\n            p = Parent2.objects.select_related(\"child2\", \"child2__child3\").get(\\n                name2=\"Child2 Parent2\"\\n            )\\n            self.assertEqual(p.child2.name1, \"Child2 Parent1\")\\n            with self.assertRaises(Child3.DoesNotExist):\\n                p.child2.child3\\n        p3 = Parent2(name2=\"Child3 Parent2\")\\n        p3.save()\\n        c2 = Child3(name1=\"Child3 Parent1\", parent2=p3, value=2, value3=3)\\n        c2.save()\\n        with self.assertNumQueries(1):\\n            p = Parent2.objects.select_related(\"child2\", \"child2__child3\").get(\\n                name2=\"Child3 Parent2\"\\n            )\\n            self.assertEqual(p.child2.name1, \"Child3 Parent1\")\\n            self.assertEqual(p.child2.child3.value3, 3)\\n            self.assertEqual(p.child2.child3.value, p.child2.value)\\n            self.assertEqual(p.child2.name1, p.child2.child3.name1)\\n\\n    def test_multiinheritance_two_subclasses(self):\\n        with self.assertNumQueries(1):\\n            p = Parent1.objects.select_related(\"child1\", \"child1__child4\").get(\\n                name1=\"Child1 Parent1\"\\n            )\\n            self.assertEqual(p.child1.name2, \"Child1 Parent2\")\\n            self.assertEqual(p.child1.name1, p.name1)\\n            with self.assertRaises(Child4.DoesNotExist):\\n                p.child1.child4\\n        Child4(name1=\"n1\", name2=\"n2\", value=1, value4=4).save()\\n        with self.assertNumQueries(1):\\n            p = Parent2.objects.select_related(\"child1\", \"child1__child4\").get(\\n                name2=\"n2\"\\n            )\\n            self.assertEqual(p.name2, \"n2\")\\n            self.assertEqual(p.child1.name1, \"n1\")\\n            self.assertEqual(p.child1.name2, p.name2)\\n            self.assertEqual(p.child1.value, 1)\\n            self.assertEqual(p.child1.child4.name1, p.child1.name1)\\n            self.assertEqual(p.child1.child4.name2, p.child1.name2)\\n            self.assertEqual(p.child1.child4.value, p.child1.value)\\n            self.assertEqual(p.child1.child4.value4, 4)\\n\\n    def test_inheritance_deferred(self):\\n        c = Child4.objects.create(name1=\"n1\", name2=\"n2\", value=1, value4=4)\\n        with self.assertNumQueries(1):\\n            p = (\\n                Parent2.objects.select_related(\"child1\")\\n                .only(\"id2\", \"child1__value\")\\n                .get(name2=\"n2\")\\n            )\\n            self.assertEqual(p.id2, c.id2)\\n            self.assertEqual(p.child1.value, 1)\\n        p = (\\n            Parent2.objects.select_related(\"child1\")\\n            .only(\"id2\", \"child1__value\")\\n            .get(name2=\"n2\")\\n        )\\n        with self.assertNumQueries(1):\\n            self.assertEqual(p.name2, \"n2\")\\n        p = (\\n            Parent2.objects.select_related(\"child1\")\\n            .only(\"id2\", \"child1__value\")\\n            .get(name2=\"n2\")\\n        )\\n        with self.assertNumQueries(1):\\n            self.assertEqual(p.child1.name2, \"n2\")\\n\\n    def test_inheritance_deferred2(self):\\n        c = Child4.objects.create(name1=\"n1\", name2=\"n2\", value=1, value4=4)\\n        qs = Parent2.objects.select_related(\"child1\", \"child1__child4\").only(\\n            \"id2\", \"child1__value\", \"child1__child4__value4\"\\n        )\\n        with self.assertNumQueries(1):\\n            p = qs.get(name2=\"n2\")\\n            self.assertEqual(p.id2, c.id2)\\n            self.assertEqual(p.child1.value, 1)\\n            self.assertEqual(p.child1.child4.value4, 4)\\n            self.assertEqual(p.child1.child4.id2, c.id2)\\n        p = qs.get(name2=\"n2\")\\n        with self.assertNumQueries(1):\\n            self.assertEqual(p.child1.name2, \"n2\")\\n        p = qs.get(name2=\"n2\")\\n        with self.assertNumQueries(0):\\n            self.assertEqual(p.child1.name1, \"n1\")\\n            self.assertEqual(p.child1.child4.name1, \"n1\")\\n\\n    def test_self_relation(self):\\n        item1 = LinkedList.objects.create(name=\"item1\")\\n        LinkedList.objects.create(name=\"item2\", previous_item=item1)\\n        with self.assertNumQueries(1):\\n            item1_db = LinkedList.objects.select_related(\"next_item\").get(name=\"item1\")\\n            self.assertEqual(item1_db.next_item.name, \"item2\")\\n",
          "lines_count": 237
        },
        {
          "file_path": "tests/auth_tests/models/proxy.py",
          "start_line": 5,
          "end_line": 17,
          "content": "class Concrete(models.Model):\\n    pass\\n\\n\\nclass Proxy(Concrete):\\n    class Meta:\\n        proxy = True\\n        permissions = ((\"display_proxys\", \"May display proxys information\"),)\\n\\n\\nclass UserProxy(User):\\n    class Meta:\\n        proxy = True\\n",
          "lines_count": 13
        },
        {
          "file_path": "tests/auth_tests/test_models.py",
          "start_line": 516,
          "end_line": 522,
          "content": "    def test_create_user(self):\\n        User.objects.create_user(\"JohnDoe\")\\n        self.assertEqual(self.signals_count, 1)\\n\\n    def test_create_superuser(self):\\n        User.objects.create_superuser(\"JohnDoe\", \"mail@example.com\", \"1\")\\n        self.assertEqual(self.signals_count, 1)\\n",
          "lines_count": 7
        },
        {
          "file_path": "tests/auth_tests/test_models.py",
          "start_line": 520,
          "end_line": 522,
          "content": "    def test_create_superuser(self):\\n        User.objects.create_superuser(\"JohnDoe\", \"mail@example.com\", \"1\")\\n        self.assertEqual(self.signals_count, 1)\\n",
          "lines_count": 3
        },
        {
          "file_path": "tests/select_related_onetoone/tests.py",
          "start_line": 24,
          "end_line": 260,
          "content": "class ReverseSelectRelatedTestCase(TestCase):\\n    @classmethod\\n    def setUpTestData(cls):\\n        user = User.objects.create(username=\"test\")\\n        UserProfile.objects.create(user=user, state=\"KS\", city=\"Lawrence\")\\n        results = UserStatResult.objects.create(results=\"first results\")\\n        userstat = UserStat.objects.create(user=user, posts=150, results=results)\\n        StatDetails.objects.create(base_stats=userstat, comments=259)\\n\\n        user2 = User.objects.create(username=\"bob\")\\n        results2 = UserStatResult.objects.create(results=\"moar results\")\\n        advstat = AdvancedUserStat.objects.create(\\n            user=user2, posts=200, karma=5, results=results2\\n        )\\n        StatDetails.objects.create(base_stats=advstat, comments=250)\\n        p1 = Parent1(name1=\"Only Parent1\")\\n        p1.save()\\n        c1 = Child1(name1=\"Child1 Parent1\", name2=\"Child1 Parent2\", value=1)\\n        c1.save()\\n        p2 = Parent2(name2=\"Child2 Parent2\")\\n        p2.save()\\n        c2 = Child2(name1=\"Child2 Parent1\", parent2=p2, value=2)\\n        c2.save()\\n\\n    def test_basic(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\"userprofile\").get(username=\"test\")\\n            self.assertEqual(u.userprofile.state, \"KS\")\\n\\n    def test_follow_next_level(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\"userstat__results\").get(username=\"test\")\\n            self.assertEqual(u.userstat.posts, 150)\\n            self.assertEqual(u.userstat.results.results, \"first results\")\\n\\n    def test_follow_two(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\"userprofile\", \"userstat\").get(\\n                username=\"test\"\\n            )\\n            self.assertEqual(u.userprofile.state, \"KS\")\\n            self.assertEqual(u.userstat.posts, 150)\\n\\n    def test_follow_two_next_level(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\\n                \"userstat__results\", \"userstat__statdetails\"\\n            ).get(username=\"test\")\\n            self.assertEqual(u.userstat.results.results, \"first results\")\\n            self.assertEqual(u.userstat.statdetails.comments, 259)\\n\\n    def test_forward_and_back(self):\\n        with self.assertNumQueries(1):\\n            stat = UserStat.objects.select_related(\"user__userprofile\").get(\\n                user__username=\"test\"\\n            )\\n            self.assertEqual(stat.user.userprofile.state, \"KS\")\\n            self.assertEqual(stat.user.userstat.posts, 150)\\n\\n    def test_back_and_forward(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\"userstat\").get(username=\"test\")\\n            self.assertEqual(u.userstat.user.username, \"test\")\\n\\n    def test_not_followed_by_default(self):\\n        with self.assertNumQueries(2):\\n            u = User.objects.select_related().get(username=\"test\")\\n            self.assertEqual(u.userstat.posts, 150)\\n\\n    def test_follow_from_child_class(self):\\n        with self.assertNumQueries(1):\\n            stat = AdvancedUserStat.objects.select_related(\"user\", \"statdetails\").get(\\n                posts=200\\n            )\\n            self.assertEqual(stat.statdetails.comments, 250)\\n            self.assertEqual(stat.user.username, \"bob\")\\n\\n    def test_follow_inheritance(self):\\n        with self.assertNumQueries(1):\\n            stat = UserStat.objects.select_related(\"user\", \"advanceduserstat\").get(\\n                posts=200\\n            )\\n            self.assertEqual(stat.advanceduserstat.posts, 200)\\n            self.assertEqual(stat.user.username, \"bob\")\\n        with self.assertNumQueries(0):\\n            self.assertEqual(stat.advanceduserstat.user.username, \"bob\")\\n\\n    def test_nullable_relation(self):\\n        im = Image.objects.create(name=\"imag1\")\\n        p1 = Product.objects.create(name=\"Django Plushie\", image=im)\\n        p2 = Product.objects.create(name=\"Talking Django Plushie\")\\n\\n        with self.assertNumQueries(1):\\n            result = sorted(\\n                Product.objects.select_related(\"image\"), key=lambda x: x.name\\n            )\\n            self.assertEqual(\\n                [p.name for p in result], [\"Django Plushie\", \"Talking Django Plushie\"]\\n            )\\n\\n            self.assertEqual(p1.image, im)\\n            # Check for ticket #13839\\n            self.assertIsNone(p2.image)\\n\\n    def test_missing_reverse(self):\\n        \"\"\"\\n        Ticket #13839: select_related() should NOT cache None\\n        for missing objects on a reverse 1-1 relation.\\n        \"\"\"\\n        with self.assertNumQueries(1):\\n            user = User.objects.select_related(\"userprofile\").get(username=\"bob\")\\n            with self.assertRaises(UserProfile.DoesNotExist):\\n                user.userprofile\\n\\n    def test_nullable_missing_reverse(self):\\n        \"\"\"\\n        Ticket #13839: select_related() should NOT cache None\\n        for missing objects on a reverse 0-1 relation.\\n        \"\"\"\\n        Image.objects.create(name=\"imag1\")\\n\\n        with self.assertNumQueries(1):\\n            image = Image.objects.select_related(\"product\").get()\\n            with self.assertRaises(Product.DoesNotExist):\\n                image.product\\n\\n    def test_parent_only(self):\\n        with self.assertNumQueries(1):\\n            p = Parent1.objects.select_related(\"child1\").get(name1=\"Only Parent1\")\\n        with self.assertNumQueries(0):\\n            with self.assertRaises(Child1.DoesNotExist):\\n                p.child1\\n\\n    def test_multiple_subclass(self):\\n        with self.assertNumQueries(1):\\n            p = Parent1.objects.select_related(\"child1\").get(name1=\"Child1 Parent1\")\\n            self.assertEqual(p.child1.name2, \"Child1 Parent2\")\\n\\n    def test_onetoone_with_subclass(self):\\n        with self.assertNumQueries(1):\\n            p = Parent2.objects.select_related(\"child2\").get(name2=\"Child2 Parent2\")\\n            self.assertEqual(p.child2.name1, \"Child2 Parent1\")\\n\\n    def test_onetoone_with_two_subclasses(self):\\n        with self.assertNumQueries(1):\\n            p = Parent2.objects.select_related(\"child2\", \"child2__child3\").get(\\n                name2=\"Child2 Parent2\"\\n            )\\n            self.assertEqual(p.child2.name1, \"Child2 Parent1\")\\n            with self.assertRaises(Child3.DoesNotExist):\\n                p.child2.child3\\n        p3 = Parent2(name2=\"Child3 Parent2\")\\n        p3.save()\\n        c2 = Child3(name1=\"Child3 Parent1\", parent2=p3, value=2, value3=3)\\n        c2.save()\\n        with self.assertNumQueries(1):\\n            p = Parent2.objects.select_related(\"child2\", \"child2__child3\").get(\\n                name2=\"Child3 Parent2\"\\n            )\\n            self.assertEqual(p.child2.name1, \"Child3 Parent1\")\\n            self.assertEqual(p.child2.child3.value3, 3)\\n            self.assertEqual(p.child2.child3.value, p.child2.value)\\n            self.assertEqual(p.child2.name1, p.child2.child3.name1)\\n\\n    def test_multiinheritance_two_subclasses(self):\\n        with self.assertNumQueries(1):\\n            p = Parent1.objects.select_related(\"child1\", \"child1__child4\").get(\\n                name1=\"Child1 Parent1\"\\n            )\\n            self.assertEqual(p.child1.name2, \"Child1 Parent2\")\\n            self.assertEqual(p.child1.name1, p.name1)\\n            with self.assertRaises(Child4.DoesNotExist):\\n                p.child1.child4\\n        Child4(name1=\"n1\", name2=\"n2\", value=1, value4=4).save()\\n        with self.assertNumQueries(1):\\n            p = Parent2.objects.select_related(\"child1\", \"child1__child4\").get(\\n                name2=\"n2\"\\n            )\\n            self.assertEqual(p.name2, \"n2\")\\n            self.assertEqual(p.child1.name1, \"n1\")\\n            self.assertEqual(p.child1.name2, p.name2)\\n            self.assertEqual(p.child1.value, 1)\\n            self.assertEqual(p.child1.child4.name1, p.child1.name1)\\n            self.assertEqual(p.child1.child4.name2, p.child1.name2)\\n            self.assertEqual(p.child1.child4.value, p.child1.value)\\n            self.assertEqual(p.child1.child4.value4, 4)\\n\\n    def test_inheritance_deferred(self):\\n        c = Child4.objects.create(name1=\"n1\", name2=\"n2\", value=1, value4=4)\\n        with self.assertNumQueries(1):\\n            p = (\\n                Parent2.objects.select_related(\"child1\")\\n                .only(\"id2\", \"child1__value\")\\n                .get(name2=\"n2\")\\n            )\\n            self.assertEqual(p.id2, c.id2)\\n            self.assertEqual(p.child1.value, 1)\\n        p = (\\n            Parent2.objects.select_related(\"child1\")\\n            .only(\"id2\", \"child1__value\")\\n            .get(name2=\"n2\")\\n        )\\n        with self.assertNumQueries(1):\\n            self.assertEqual(p.name2, \"n2\")\\n        p = (\\n            Parent2.objects.select_related(\"child1\")\\n            .only(\"id2\", \"child1__value\")\\n            .get(name2=\"n2\")\\n        )\\n        with self.assertNumQueries(1):\\n            self.assertEqual(p.child1.name2, \"n2\")\\n\\n    def test_inheritance_deferred2(self):\\n        c = Child4.objects.create(name1=\"n1\", name2=\"n2\", value=1, value4=4)\\n        qs = Parent2.objects.select_related(\"child1\", \"child1__child4\").only(\\n            \"id2\", \"child1__value\", \"child1__child4__value4\"\\n        )\\n        with self.assertNumQueries(1):\\n            p = qs.get(name2=\"n2\")\\n            self.assertEqual(p.id2, c.id2)\\n            self.assertEqual(p.child1.value, 1)\\n            self.assertEqual(p.child1.child4.value4, 4)\\n            self.assertEqual(p.child1.child4.id2, c.id2)\\n        p = qs.get(name2=\"n2\")\\n        with self.assertNumQueries(1):\\n            self.assertEqual(p.child1.name2, \"n2\")\\n        p = qs.get(name2=\"n2\")\\n        with self.assertNumQueries(0):\\n            self.assertEqual(p.child1.name1, \"n1\")\\n            self.assertEqual(p.child1.child4.name1, \"n1\")\\n\\n    def test_self_relation(self):\\n        item1 = LinkedList.objects.create(name=\"item1\")\\n        LinkedList.objects.create(name=\"item2\", previous_item=item1)\\n        with self.assertNumQueries(1):\\n            item1_db = LinkedList.objects.select_related(\"next_item\").get(name=\"item1\")\\n            self.assertEqual(item1_db.next_item.name, \"item2\")\\n",
          "lines_count": 237
        },
        {
          "file_path": "tests/proxy_models/tests.py",
          "start_line": 313,
          "end_line": 332,
          "content": "    def test_select_related(self):\\n        \"\"\"\\n        We can still use `select_related()` to include related models in our\\n        querysets.\\n        \"\"\"\\n        country = Country.objects.create(name=\"Australia\")\\n        State.objects.create(name=\"New South Wales\", country=country)\\n\\n        resp = [s.name for s in State.objects.select_related()]\\n        self.assertEqual(resp, [\"New South Wales\"])\\n\\n        resp = [s.name for s in StateProxy.objects.select_related()]\\n        self.assertEqual(resp, [\"New South Wales\"])\\n\\n        self.assertEqual(\\n            StateProxy.objects.get(name=\"New South Wales\").name, \"New South Wales\"\\n        )\\n\\n        resp = StateProxy.objects.select_related().get(name=\"New South Wales\")\\n        self.assertEqual(resp.name, \"New South Wales\")\\n",
          "lines_count": 20
        },
        {
          "file_path": "tests/auth_tests/models/proxy.py",
          "start_line": 5,
          "end_line": 17,
          "content": "class Concrete(models.Model):\\n    pass\\n\\n\\nclass Proxy(Concrete):\\n    class Meta:\\n        proxy = True\\n        permissions = ((\"display_proxys\", \"May display proxys information\"),)\\n\\n\\nclass UserProxy(User):\\n    class Meta:\\n        proxy = True\\n",
          "lines_count": 13
        },
        {
          "file_path": "tests/auth_tests/test_models.py",
          "start_line": 516,
          "end_line": 522,
          "content": "    def test_create_user(self):\\n        User.objects.create_user(\"JohnDoe\")\\n        self.assertEqual(self.signals_count, 1)\\n\\n    def test_create_superuser(self):\\n        User.objects.create_superuser(\"JohnDoe\", \"mail@example.com\", \"1\")\\n        self.assertEqual(self.signals_count, 1)\\n",
          "lines_count": 7
        },
        {
          "file_path": "tests/auth_tests/test_models.py",
          "start_line": 520,
          "end_line": 522,
          "content": "    def test_create_superuser(self):\\n        User.objects.create_superuser(\"JohnDoe\", \"mail@example.com\", \"1\")\\n        self.assertEqual(self.signals_count, 1)\\n",
          "lines_count": 3
        },
        {
          "file_path": "tests/select_related_onetoone/tests.py",
          "start_line": 24,
          "end_line": 260,
          "content": "class ReverseSelectRelatedTestCase(TestCase):\\n    @classmethod\\n    def setUpTestData(cls):\\n        user = User.objects.create(username=\"test\")\\n        UserProfile.objects.create(user=user, state=\"KS\", city=\"Lawrence\")\\n        results = UserStatResult.objects.create(results=\"first results\")\\n        userstat = UserStat.objects.create(user=user, posts=150, results=results)\\n        StatDetails.objects.create(base_stats=userstat, comments=259)\\n\\n        user2 = User.objects.create(username=\"bob\")\\n        results2 = UserStatResult.objects.create(results=\"moar results\")\\n        advstat = AdvancedUserStat.objects.create(\\n            user=user2, posts=200, karma=5, results=results2\\n        )\\n        StatDetails.objects.create(base_stats=advstat, comments=250)\\n        p1 = Parent1(name1=\"Only Parent1\")\\n        p1.save()\\n        c1 = Child1(name1=\"Child1 Parent1\", name2=\"Child1 Parent2\", value=1)\\n        c1.save()\\n        p2 = Parent2(name2=\"Child2 Parent2\")\\n        p2.save()\\n        c2 = Child2(name1=\"Child2 Parent1\", parent2=p2, value=2)\\n        c2.save()\\n\\n    def test_basic(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\"userprofile\").get(username=\"test\")\\n            self.assertEqual(u.userprofile.state, \"KS\")\\n\\n    def test_follow_next_level(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\"userstat__results\").get(username=\"test\")\\n            self.assertEqual(u.userstat.posts, 150)\\n            self.assertEqual(u.userstat.results.results, \"first results\")\\n\\n    def test_follow_two(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\"userprofile\", \"userstat\").get(\\n                username=\"test\"\\n            )\\n            self.assertEqual(u.userprofile.state, \"KS\")\\n            self.assertEqual(u.userstat.posts, 150)\\n\\n    def test_follow_two_next_level(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\\n                \"userstat__results\", \"userstat__statdetails\"\\n            ).get(username=\"test\")\\n            self.assertEqual(u.userstat.results.results, \"first results\")\\n            self.assertEqual(u.userstat.statdetails.comments, 259)\\n\\n    def test_forward_and_back(self):\\n        with self.assertNumQueries(1):\\n            stat = UserStat.objects.select_related(\"user__userprofile\").get(\\n                user__username=\"test\"\\n            )\\n            self.assertEqual(stat.user.userprofile.state, \"KS\")\\n            self.assertEqual(stat.user.userstat.posts, 150)\\n\\n    def test_back_and_forward(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\"userstat\").get(username=\"test\")\\n            self.assertEqual(u.userstat.user.username, \"test\")\\n\\n    def test_not_followed_by_default(self):\\n        with self.assertNumQueries(2):\\n            u = User.objects.select_related().get(username=\"test\")\\n            self.assertEqual(u.userstat.posts, 150)\\n\\n    def test_follow_from_child_class(self):\\n        with self.assertNumQueries(1):\\n            stat = AdvancedUserStat.objects.select_related(\"user\", \"statdetails\").get(\\n                posts=200\\n            )\\n            self.assertEqual(stat.statdetails.comments, 250)\\n            self.assertEqual(stat.user.username, \"bob\")\\n\\n    def test_follow_inheritance(self):\\n        with self.assertNumQueries(1):\\n            stat = UserStat.objects.select_related(\"user\", \"advanceduserstat\").get(\\n                posts=200\\n            )\\n            self.assertEqual(stat.advanceduserstat.posts, 200)\\n            self.assertEqual(stat.user.username, \"bob\")\\n        with self.assertNumQueries(0):\\n            self.assertEqual(stat.advanceduserstat.user.username, \"bob\")\\n\\n    def test_nullable_relation(self):\\n        im = Image.objects.create(name=\"imag1\")\\n        p1 = Product.objects.create(name=\"Django Plushie\", image=im)\\n        p2 = Product.objects.create(name=\"Talking Django Plushie\")\\n\\n        with self.assertNumQueries(1):\\n            result = sorted(\\n                Product.objects.select_related(\"image\"), key=lambda x: x.name\\n            )\\n            self.assertEqual(\\n                [p.name for p in result], [\"Django Plushie\", \"Talking Django Plushie\"]\\n            )\\n\\n            self.assertEqual(p1.image, im)\\n            # Check for ticket #13839\\n            self.assertIsNone(p2.image)\\n\\n    def test_missing_reverse(self):\\n        \"\"\"\\n        Ticket #13839: select_related() should NOT cache None\\n        for missing objects on a reverse 1-1 relation.\\n        \"\"\"\\n        with self.assertNumQueries(1):\\n            user = User.objects.select_related(\"userprofile\").get(username=\"bob\")\\n            with self.assertRaises(UserProfile.DoesNotExist):\\n                user.userprofile\\n\\n    def test_nullable_missing_reverse(self):\\n        \"\"\"\\n        Ticket #13839: select_related() should NOT cache None\\n        for missing objects on a reverse 0-1 relation.\\n        \"\"\"\\n        Image.objects.create(name=\"imag1\")\\n\\n        with self.assertNumQueries(1):\\n            image = Image.objects.select_related(\"product\").get()\\n            with self.assertRaises(Product.DoesNotExist):\\n                image.product\\n\\n    def test_parent_only(self):\\n        with self.assertNumQueries(1):\\n            p = Parent1.objects.select_related(\"child1\").get(name1=\"Only Parent1\")\\n        with self.assertNumQueries(0):\\n            with self.assertRaises(Child1.DoesNotExist):\\n                p.child1\\n\\n    def test_multiple_subclass(self):\\n        with self.assertNumQueries(1):\\n            p = Parent1.objects.select_related(\"child1\").get(name1=\"Child1 Parent1\")\\n            self.assertEqual(p.child1.name2, \"Child1 Parent2\")\\n\\n    def test_onetoone_with_subclass(self):\\n        with self.assertNumQueries(1):\\n            p = Parent2.objects.select_related(\"child2\").get(name2=\"Child2 Parent2\")\\n            self.assertEqual(p.child2.name1, \"Child2 Parent1\")\\n\\n    def test_onetoone_with_two_subclasses(self):\\n        with self.assertNumQueries(1):\\n            p = Parent2.objects.select_related(\"child2\", \"child2__child3\").get(\\n                name2=\"Child2 Parent2\"\\n            )\\n            self.assertEqual(p.child2.name1, \"Child2 Parent1\")\\n            with self.assertRaises(Child3.DoesNotExist):\\n                p.child2.child3\\n        p3 = Parent2(name2=\"Child3 Parent2\")\\n        p3.save()\\n        c2 = Child3(name1=\"Child3 Parent1\", parent2=p3, value=2, value3=3)\\n        c2.save()\\n        with self.assertNumQueries(1):\\n            p = Parent2.objects.select_related(\"child2\", \"child2__child3\").get(\\n                name2=\"Child3 Parent2\"\\n            )\\n            self.assertEqual(p.child2.name1, \"Child3 Parent1\")\\n            self.assertEqual(p.child2.child3.value3, 3)\\n            self.assertEqual(p.child2.child3.value, p.child2.value)\\n            self.assertEqual(p.child2.name1, p.child2.child3.name1)\\n\\n    def test_multiinheritance_two_subclasses(self):\\n        with self.assertNumQueries(1):\\n            p = Parent1.objects.select_related(\"child1\", \"child1__child4\").get(\\n                name1=\"Child1 Parent1\"\\n            )\\n            self.assertEqual(p.child1.name2, \"Child1 Parent2\")\\n            self.assertEqual(p.child1.name1, p.name1)\\n            with self.assertRaises(Child4.DoesNotExist):\\n                p.child1.child4\\n        Child4(name1=\"n1\", name2=\"n2\", value=1, value4=4).save()\\n        with self.assertNumQueries(1):\\n            p = Parent2.objects.select_related(\"child1\", \"child1__child4\").get(\\n                name2=\"n2\"\\n            )\\n            self.assertEqual(p.name2, \"n2\")\\n            self.assertEqual(p.child1.name1, \"n1\")\\n            self.assertEqual(p.child1.name2, p.name2)\\n            self.assertEqual(p.child1.value, 1)\\n            self.assertEqual(p.child1.child4.name1, p.child1.name1)\\n            self.assertEqual(p.child1.child4.name2, p.child1.name2)\\n            self.assertEqual(p.child1.child4.value, p.child1.value)\\n            self.assertEqual(p.child1.child4.value4, 4)\\n\\n    def test_inheritance_deferred(self):\\n        c = Child4.objects.create(name1=\"n1\", name2=\"n2\", value=1, value4=4)\\n        with self.assertNumQueries(1):\\n            p = (\\n                Parent2.objects.select_related(\"child1\")\\n                .only(\"id2\", \"child1__value\")\\n                .get(name2=\"n2\")\\n            )\\n            self.assertEqual(p.id2, c.id2)\\n            self.assertEqual(p.child1.value, 1)\\n        p = (\\n            Parent2.objects.select_related(\"child1\")\\n            .only(\"id2\", \"child1__value\")\\n            .get(name2=\"n2\")\\n        )\\n        with self.assertNumQueries(1):\\n            self.assertEqual(p.name2, \"n2\")\\n        p = (\\n            Parent2.objects.select_related(\"child1\")\\n            .only(\"id2\", \"child1__value\")\\n            .get(name2=\"n2\")\\n        )\\n        with self.assertNumQueries(1):\\n            self.assertEqual(p.child1.name2, \"n2\")\\n\\n    def test_inheritance_deferred2(self):\\n        c = Child4.objects.create(name1=\"n1\", name2=\"n2\", value=1, value4=4)\\n        qs = Parent2.objects.select_related(\"child1\", \"child1__child4\").only(\\n            \"id2\", \"child1__value\", \"child1__child4__value4\"\\n        )\\n        with self.assertNumQueries(1):\\n            p = qs.get(name2=\"n2\")\\n            self.assertEqual(p.id2, c.id2)\\n            self.assertEqual(p.child1.value, 1)\\n            self.assertEqual(p.child1.child4.value4, 4)\\n            self.assertEqual(p.child1.child4.id2, c.id2)\\n        p = qs.get(name2=\"n2\")\\n        with self.assertNumQueries(1):\\n            self.assertEqual(p.child1.name2, \"n2\")\\n        p = qs.get(name2=\"n2\")\\n        with self.assertNumQueries(0):\\n            self.assertEqual(p.child1.name1, \"n1\")\\n            self.assertEqual(p.child1.child4.name1, \"n1\")\\n\\n    def test_self_relation(self):\\n        item1 = LinkedList.objects.create(name=\"item1\")\\n        LinkedList.objects.create(name=\"item2\", previous_item=item1)\\n        with self.assertNumQueries(1):\\n            item1_db = LinkedList.objects.select_related(\"next_item\").get(name=\"item1\")\\n            self.assertEqual(item1_db.next_item.name, \"item2\")\\n",
          "lines_count": 237
        },
        {
          "file_path": "tests/proxy_models/tests.py",
          "start_line": 313,
          "end_line": 332,
          "content": "    def test_select_related(self):\\n        \"\"\"\\n        We can still use `select_related()` to include related models in our\\n        querysets.\\n        \"\"\"\\n        country = Country.objects.create(name=\"Australia\")\\n        State.objects.create(name=\"New South Wales\", country=country)\\n\\n        resp = [s.name for s in State.objects.select_related()]\\n        self.assertEqual(resp, [\"New South Wales\"])\\n\\n        resp = [s.name for s in StateProxy.objects.select_related()]\\n        self.assertEqual(resp, [\"New South Wales\"])\\n\\n        self.assertEqual(\\n            StateProxy.objects.get(name=\"New South Wales\").name, \"New South Wales\"\\n        )\\n\\n        resp = StateProxy.objects.select_related().get(name=\"New South Wales\")\\n        self.assertEqual(resp.name, \"New South Wales\")\\n",
          "lines_count": 20
        },
        {
          "file_path": "tests/defer/tests.py",
          "start_line": 126,
          "end_line": 147,
          "content": "    def test_only_with_select_related(self):\\n        obj = Primary.objects.select_related().only(\"related__first\")[0]\\n        self.assert_delayed(obj, 2)\\n        self.assert_delayed(obj.related, 1)\\n        self.assertEqual(obj.related_id, self.s1.pk)\\n        self.assertEqual(obj.name, \"p1\")\\n\\n    def test_defer_select_related_raises_invalid_query(self):\\n        msg = (\\n            \"Field Primary.related cannot be both deferred and traversed \"\\n            \"using select_related at the same time.\"\\n        )\\n        with self.assertRaisesMessage(FieldError, msg):\\n            Primary.objects.defer(\"related\").select_related(\"related\")[0]\\n\\n    def test_only_select_related_raises_invalid_query(self):\\n        msg = (\\n            \"Field Primary.related cannot be both deferred and traversed using \"\\n            \"select_related at the same time.\"\\n        )\\n        with self.assertRaisesMessage(FieldError, msg):\\n            Primary.objects.only(\"name\").select_related(\"related\")[0]\\n",
          "lines_count": 22
        },
        {
          "file_path": "tests/auth_tests/models/proxy.py",
          "start_line": 5,
          "end_line": 17,
          "content": "class Concrete(models.Model):\\n    pass\\n\\n\\nclass Proxy(Concrete):\\n    class Meta:\\n        proxy = True\\n        permissions = ((\"display_proxys\", \"May display proxys information\"),)\\n\\n\\nclass UserProxy(User):\\n    class Meta:\\n        proxy = True\\n",
          "lines_count": 13
        },
        {
          "file_path": "tests/auth_tests/test_models.py",
          "start_line": 516,
          "end_line": 522,
          "content": "    def test_create_user(self):\\n        User.objects.create_user(\"JohnDoe\")\\n        self.assertEqual(self.signals_count, 1)\\n\\n    def test_create_superuser(self):\\n        User.objects.create_superuser(\"JohnDoe\", \"mail@example.com\", \"1\")\\n        self.assertEqual(self.signals_count, 1)\\n",
          "lines_count": 7
        },
        {
          "file_path": "tests/auth_tests/test_models.py",
          "start_line": 520,
          "end_line": 522,
          "content": "    def test_create_superuser(self):\\n        User.objects.create_superuser(\"JohnDoe\", \"mail@example.com\", \"1\")\\n        self.assertEqual(self.signals_count, 1)\\n",
          "lines_count": 3
        },
        {
          "file_path": "tests/select_related_onetoone/tests.py",
          "start_line": 24,
          "end_line": 260,
          "content": "class ReverseSelectRelatedTestCase(TestCase):\\n    @classmethod\\n    def setUpTestData(cls):\\n        user = User.objects.create(username=\"test\")\\n        UserProfile.objects.create(user=user, state=\"KS\", city=\"Lawrence\")\\n        results = UserStatResult.objects.create(results=\"first results\")\\n        userstat = UserStat.objects.create(user=user, posts=150, results=results)\\n        StatDetails.objects.create(base_stats=userstat, comments=259)\\n\\n        user2 = User.objects.create(username=\"bob\")\\n        results2 = UserStatResult.objects.create(results=\"moar results\")\\n        advstat = AdvancedUserStat.objects.create(\\n            user=user2, posts=200, karma=5, results=results2\\n        )\\n        StatDetails.objects.create(base_stats=advstat, comments=250)\\n        p1 = Parent1(name1=\"Only Parent1\")\\n        p1.save()\\n        c1 = Child1(name1=\"Child1 Parent1\", name2=\"Child1 Parent2\", value=1)\\n        c1.save()\\n        p2 = Parent2(name2=\"Child2 Parent2\")\\n        p2.save()\\n        c2 = Child2(name1=\"Child2 Parent1\", parent2=p2, value=2)\\n        c2.save()\\n\\n    def test_basic(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\"userprofile\").get(username=\"test\")\\n            self.assertEqual(u.userprofile.state, \"KS\")\\n\\n    def test_follow_next_level(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\"userstat__results\").get(username=\"test\")\\n            self.assertEqual(u.userstat.posts, 150)\\n            self.assertEqual(u.userstat.results.results, \"first results\")\\n\\n    def test_follow_two(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\"userprofile\", \"userstat\").get(\\n                username=\"test\"\\n            )\\n            self.assertEqual(u.userprofile.state, \"KS\")\\n            self.assertEqual(u.userstat.posts, 150)\\n\\n    def test_follow_two_next_level(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\\n                \"userstat__results\", \"userstat__statdetails\"\\n            ).get(username=\"test\")\\n            self.assertEqual(u.userstat.results.results, \"first results\")\\n            self.assertEqual(u.userstat.statdetails.comments, 259)\\n\\n    def test_forward_and_back(self):\\n        with self.assertNumQueries(1):\\n            stat = UserStat.objects.select_related(\"user__userprofile\").get(\\n                user__username=\"test\"\\n            )\\n            self.assertEqual(stat.user.userprofile.state, \"KS\")\\n            self.assertEqual(stat.user.userstat.posts, 150)\\n\\n    def test_back_and_forward(self):\\n        with self.assertNumQueries(1):\\n            u = User.objects.select_related(\"userstat\").get(username=\"test\")\\n            self.assertEqual(u.userstat.user.username, \"test\")\\n\\n    def test_not_followed_by_default(self):\\n        with self.assertNumQueries(2):\\n            u = User.objects.select_related().get(username=\"test\")\\n            self.assertEqual(u.userstat.posts, 150)\\n\\n    def test_follow_from_child_class(self):\\n        with self.assertNumQueries(1):\\n            stat = AdvancedUserStat.objects.select_related(\"user\", \"statdetails\").get(\\n                posts=200\\n            )\\n            self.assertEqual(stat.statdetails.comments, 250)\\n            self.assertEqual(stat.user.username, \"bob\")\\n\\n    def test_follow_inheritance(self):\\n        with self.assertNumQueries(1):\\n            stat = UserStat.objects.select_related(\"user\", \"advanceduserstat\").get(\\n                posts=200\\n            )\\n            self.assertEqual(stat.advanceduserstat.posts, 200)\\n            self.assertEqual(stat.user.username, \"bob\")\\n        with self.assertNumQueries(0):\\n            self.assertEqual(stat.advanceduserstat.user.username, \"bob\")\\n\\n    def test_nullable_relation(self):\\n        im = Image.objects.create(name=\"imag1\")\\n        p1 = Product.objects.create(name=\"Django Plushie\", image=im)\\n        p2 = Product.objects.create(name=\"Talking Django Plushie\")\\n\\n        with self.assertNumQueries(1):\\n            result = sorted(\\n                Product.objects.select_related(\"image\"), key=lambda x: x.name\\n            )\\n            self.assertEqual(\\n                [p.name for p in result], [\"Django Plushie\", \"Talking Django Plushie\"]\\n            )\\n\\n            self.assertEqual(p1.image, im)\\n            # Check for ticket #13839\\n            self.assertIsNone(p2.image)\\n\\n    def test_missing_reverse(self):\\n        \"\"\"\\n        Ticket #13839: select_related() should NOT cache None\\n        for missing objects on a reverse 1-1 relation.\\n        \"\"\"\\n        with self.assertNumQueries(1):\\n            user = User.objects.select_related(\"userprofile\").get(username=\"bob\")\\n            with self.assertRaises(UserProfile.DoesNotExist):\\n                user.userprofile\\n\\n    def test_nullable_missing_reverse(self):\\n        \"\"\"\\n        Ticket #13839: select_related() should NOT cache None\\n        for missing objects on a reverse 0-1 relation.\\n        \"\"\"\\n        Image.objects.create(name=\"imag1\")\\n\\n        with self.assertNumQueries(1):\\n            image = Image.objects.select_related(\"product\").get()\\n            with self.assertRaises(Product.DoesNotExist):\\n                image.product\\n\\n    def test_parent_only(self):\\n        with self.assertNumQueries(1):\\n            p = Parent1.objects.select_related(\"child1\").get(name1=\"Only Parent1\")\\n        with self.assertNumQueries(0):\\n            with self.assertRaises(Child1.DoesNotExist):\\n                p.child1\\n\\n    def test_multiple_subclass(self):\\n        with self.assertNumQueries(1):\\n            p = Parent1.objects.select_related(\"child1\").get(name1=\"Child1 Parent1\")\\n            self.assertEqual(p.child1.name2, \"Child1 Parent2\")\\n\\n    def test_onetoone_with_subclass(self):\\n        with self.assertNumQueries(1):\\n            p = Parent2.objects.select_related(\"child2\").get(name2=\"Child2 Parent2\")\\n            self.assertEqual(p.child2.name1, \"Child2 Parent1\")\\n\\n    def test_onetoone_with_two_subclasses(self):\\n        with self.assertNumQueries(1):\\n            p = Parent2.objects.select_related(\"child2\", \"child2__child3\").get(\\n                name2=\"Child2 Parent2\"\\n            )\\n            self.assertEqual(p.child2.name1, \"Child2 Parent1\")\\n            with self.assertRaises(Child3.DoesNotExist):\\n                p.child2.child3\\n        p3 = Parent2(name2=\"Child3 Parent2\")\\n        p3.save()\\n        c2 = Child3(name1=\"Child3 Parent1\", parent2=p3, value=2, value3=3)\\n        c2.save()\\n        with self.assertNumQueries(1):\\n            p = Parent2.objects.select_related(\"child2\", \"child2__child3\").get(\\n                name2=\"Child3 Parent2\"\\n            )\\n            self.assertEqual(p.child2.name1, \"Child3 Parent1\")\\n            self.assertEqual(p.child2.child3.value3, 3)\\n            self.assertEqual(p.child2.child3.value, p.child2.value)\\n            self.assertEqual(p.child2.name1, p.child2.child3.name1)\\n\\n    def test_multiinheritance_two_subclasses(self):\\n        with self.assertNumQueries(1):\\n            p = Parent1.objects.select_related(\"child1\", \"child1__child4\").get(\\n                name1=\"Child1 Parent1\"\\n            )\\n            self.assertEqual(p.child1.name2, \"Child1 Parent2\")\\n            self.assertEqual(p.child1.name1, p.name1)\\n            with self.assertRaises(Child4.DoesNotExist):\\n                p.child1.child4\\n        Child4(name1=\"n1\", name2=\"n2\", value=1, value4=4).save()\\n        with self.assertNumQueries(1):\\n            p = Parent2.objects.select_related(\"child1\", \"child1__child4\").get(\\n                name2=\"n2\"\\n            )\\n            self.assertEqual(p.name2, \"n2\")\\n            self.assertEqual(p.child1.name1, \"n1\")\\n            self.assertEqual(p.child1.name2, p.name2)\\n            self.assertEqual(p.child1.value, 1)\\n            self.assertEqual(p.child1.child4.name1, p.child1.name1)\\n            self.assertEqual(p.child1.child4.name2, p.child1.name2)\\n            self.assertEqual(p.child1.child4.value, p.child1.value)\\n            self.assertEqual(p.child1.child4.value4, 4)\\n\\n    def test_inheritance_deferred(self):\\n        c = Child4.objects.create(name1=\"n1\", name2=\"n2\", value=1, value4=4)\\n        with self.assertNumQueries(1):\\n            p = (\\n                Parent2.objects.select_related(\"child1\")\\n                .only(\"id2\", \"child1__value\")\\n                .get(name2=\"n2\")\\n            )\\n            self.assertEqual(p.id2, c.id2)\\n            self.assertEqual(p.child1.value, 1)\\n        p = (\\n            Parent2.objects.select_related(\"child1\")\\n            .only(\"id2\", \"child1__value\")\\n            .get(name2=\"n2\")\\n        )\\n        with self.assertNumQueries(1):\\n            self.assertEqual(p.name2, \"n2\")\\n        p = (\\n            Parent2.objects.select_related(\"child1\")\\n            .only(\"id2\", \"child1__value\")\\n            .get(name2=\"n2\")\\n        )\\n        with self.assertNumQueries(1):\\n            self.assertEqual(p.child1.name2, \"n2\")\\n\\n    def test_inheritance_deferred2(self):\\n        c = Child4.objects.create(name1=\"n1\", name2=\"n2\", value=1, value4=4)\\n        qs = Parent2.objects.select_related(\"child1\", \"child1__child4\").only(\\n            \"id2\", \"child1__value\", \"child1__child4__value4\"\\n        )\\n        with self.assertNumQueries(1):\\n            p = qs.get(name2=\"n2\")\\n            self.assertEqual(p.id2, c.id2)\\n            self.assertEqual(p.child1.value, 1)\\n            self.assertEqual(p.child1.child4.value4, 4)\\n            self.assertEqual(p.child1.child4.id2, c.id2)\\n        p = qs.get(name2=\"n2\")\\n        with self.assertNumQueries(1):\\n            self.assertEqual(p.child1.name2, \"n2\")\\n        p = qs.get(name2=\"n2\")\\n        with self.assertNumQueries(0):\\n            self.assertEqual(p.child1.name1, \"n1\")\\n            self.assertEqual(p.child1.child4.name1, \"n1\")\\n\\n    def test_self_relation(self):\\n        item1 = LinkedList.objects.create(name=\"item1\")\\n        LinkedList.objects.create(name=\"item2\", previous_item=item1)\\n        with self.assertNumQueries(1):\\n            item1_db = LinkedList.objects.select_related(\"next_item\").get(name=\"item1\")\\n            self.assertEqual(item1_db.next_item.name, \"item2\")\\n",
          "lines_count": 237
        },
        {
          "file_path": "tests/proxy_models/tests.py",
          "start_line": 313,
          "end_line": 332,
          "content": "    def test_select_related(self):\\n        \"\"\"\\n        We can still use `select_related()` to include related models in our\\n        querysets.\\n        \"\"\"\\n        country = Country.objects.create(name=\"Australia\")\\n        State.objects.create(name=\"New South Wales\", country=country)\\n\\n        resp = [s.name for s in State.objects.select_related()]\\n        self.assertEqual(resp, [\"New South Wales\"])\\n\\n        resp = [s.name for s in StateProxy.objects.select_related()]\\n        self.assertEqual(resp, [\"New South Wales\"])\\n\\n        self.assertEqual(\\n            StateProxy.objects.get(name=\"New South Wales\").name, \"New South Wales\"\\n        )\\n\\n        resp = StateProxy.objects.select_related().get(name=\"New South Wales\")\\n        self.assertEqual(resp.name, \"New South Wales\")\\n",
          "lines_count": 20
        },
        {
          "file_path": "tests/defer/tests.py",
          "start_line": 126,
          "end_line": 147,
          "content": "    def test_only_with_select_related(self):\\n        obj = Primary.objects.select_related().only(\"related__first\")[0]\\n        self.assert_delayed(obj, 2)\\n        self.assert_delayed(obj.related, 1)\\n        self.assertEqual(obj.related_id, self.s1.pk)\\n        self.assertEqual(obj.name, \"p1\")\\n\\n    def test_defer_select_related_raises_invalid_query(self):\\n        msg = (\\n            \"Field Primary.related cannot be both deferred and traversed \"\\n            \"using select_related at the same time.\"\\n        )\\n        with self.assertRaisesMessage(FieldError, msg):\\n            Primary.objects.defer(\"related\").select_related(\"related\")[0]\\n\\n    def test_only_select_related_raises_invalid_query(self):\\n        msg = (\\n            \"Field Primary.related cannot be both deferred and traversed using \"\\n            \"select_related at the same time.\"\\n        )\\n        with self.assertRaisesMessage(FieldError, msg):\\n            Primary.objects.only(\"name\").select_related(\"related\")[0]\\n",
          "lines_count": 22
        },
        {
          "file_path": "django/db/models/query.py",
          "start_line": 287,
          "end_line": 287,
          "content": "class QuerySet:\\n",
          "lines_count": 1
        },
        {
          "file_path": "django/db/models/query.py",
          "start_line": 2268,
          "end_line": 2268,
          "content": "                        obj._prefetched_objects_cache = {}\\n",
          "lines_count": 1
        },
        {
          "file_path": "django/db/models/query.py",
          "start_line": 2534,
          "end_line": 2534,
          "content": "class RelatedPopulator:\\n",
          "lines_count": 1
        },
        {
          "file_path": "django/db/models/sql/query.py",
          "start_line": 158,
          "end_line": 158,
          "content": "class Query(BaseExpression):\\n",
          "lines_count": 1
        },
        {
          "file_path": "django/db/models/query.py",
          "start_line": 287,
          "end_line": 287,
          "content": "class QuerySet:\\n",
          "lines_count": 1
        },
        {
          "file_path": "django/db/models/query.py",
          "start_line": 2268,
          "end_line": 2268,
          "content": "                        obj._prefetched_objects_cache = {}\\n",
          "lines_count": 1
        },
        {
          "file_path": "django/db/models/query.py",
          "start_line": 2534,
          "end_line": 2534,
          "content": "class RelatedPopulator:\\n",
          "lines_count": 1
        },
        {
          "file_path": "django/db/models/sql/query.py",
          "start_line": 158,
          "end_line": 158,
          "content": "class Query(BaseExpression):\\n",
          "lines_count": 1
        },
        {
          "file_path": "django/db/models/query.py",
          "start_line": 287,
          "end_line": 1972,
          "content": "class QuerySet:\\n    \"\"\"Represent a lazy database lookup for a set of objects.\"\"\"\\n\\n    def __init__(self, model=None, query=None, using=None, hints=None):\\n        self.model = model\\n        self._db = using\\n        self._hints = hints or {}\\n        self._query = query or sql.Query(self.model)\\n        self._result_cache = None\\n        self._sticky_filter = False\\n        self._for_write = False\\n        self._prefetch_related_lookups = ()\\n        self._prefetch_done = False\\n        self._known_related_objects = {}  # {rel_field: {pk: rel_obj}}\\n        self._iterable_class = ModelIterable\\n        self._fields = None\\n        self._defer_next_filter = False\\n        self._deferred_filter = None\\n\\n    @property\\n    def query(self):\\n        if self._deferred_filter:\\n            negate, args, kwargs = self._deferred_filter\\n            self._filter_or_exclude_inplace(negate, args, kwargs)\\n            self._deferred_filter = None\\n        return self._query\\n\\n    @query.setter\\n    def query(self, value):\\n        if value.values_select:\\n            self._iterable_class = ValuesIterable\\n        self._query = value\\n\\n    def as_manager(cls):\\n        # Address the circular dependency between `Queryset` and `Manager`.\\n        from django.db.models.manager import Manager\\n\\n        manager = Manager.from_queryset(cls)()\\n        manager._built_with_as_manager = True\\n        return manager\\n\\n    as_manager.queryset_only = True\\n    as_manager = classmethod(as_manager)\\n\\n    ########################\\n    # PYTHON MAGIC METHODS #\\n    ########################\\n\\n    def __deepcopy__(self, memo):\\n        \"\"\"Don\\",
          "lines_count": 1686
        },
        {
          "file_path": "django/db/models/query.py",
          "start_line": 2534,
          "end_line": 2617,
          "content": "class RelatedPopulator:\\n    \"\"\"\\n    RelatedPopulator is used for select_related() object instantiation.\\n\\n    The idea is that each select_related() model will be populated by a\\n    different RelatedPopulator instance. The RelatedPopulator instances get\\n    klass_info and select (computed in SQLCompiler) plus the used db as\\n    input for initialization. That data is used to compute which columns\\n    to use, how to instantiate the model, and how to populate the links\\n    between the objects.\\n\\n    The actual creation of the objects is done in populate() method. This\\n    method gets row and from_obj as input and populates the select_related()\\n    model instance.\\n    \"\"\"\\n\\n    def __init__(self, klass_info, select, db):\\n        self.db = db\\n        # Pre-compute needed attributes. The attributes are:\\n        #  - model_cls: the possibly deferred model class to instantiate\\n        #  - either:\\n        #    - cols_start, cols_end: usually the columns in the row are\\n        #      in the same order model_cls.__init__ expects them, so we\\n        #      can instantiate by model_cls(*row[cols_start:cols_end])\\n        #    - reorder_for_init: When select_related descends to a child\\n        #      class, then we want to reuse the already selected parent\\n        #      data. However, in this case the parent data isn\\",
          "lines_count": 84
        },
        {
          "file_path": "django/db/models/sql/query.py",
          "start_line": 158,
          "end_line": 800,
          "content": "class Query(BaseExpression):\\n    \"\"\"A single SQL query.\"\"\"\\n\\n    alias_prefix = \"T\"\\n    empty_result_set_value = None\\n    subq_aliases = frozenset([alias_prefix])\\n\\n    compiler = \"SQLCompiler\"\\n\\n    base_table_class = BaseTable\\n    join_class = Join\\n\\n    default_cols = True\\n    default_ordering = True\\n    standard_ordering = True\\n\\n    filter_is_sticky = False\\n    subquery = False\\n\\n    # SQL-related attributes.\\n    # Select and related select clauses are expressions to use in the SELECT\\n    # clause of the query. The select is used for cases where we want to set up\\n    # the select clause to contain other than default fields (values(),\\n    # subqueries...). Note that annotations go to annotations dictionary.\\n    select = ()\\n    # The group_by attribute can have one of the following forms:\\n    #  - None: no group by at all in the query\\n    #  - A tuple of expressions: group by (at least) those expressions.\\n    #    String refs are also allowed for now.\\n    #  - True: group by all select fields of the model\\n    # See compiler.get_group_by() for details.\\n    group_by = None\\n    order_by = ()\\n    low_mark = 0  # Used for offset/limit.\\n    high_mark = None  # Used for offset/limit.\\n    distinct = False\\n    distinct_fields = ()\\n    select_for_update = False\\n    select_for_update_nowait = False\\n    select_for_update_skip_locked = False\\n    select_for_update_of = ()\\n    select_for_no_key_update = False\\n    select_related = False\\n    # Arbitrary limit for select_related to prevents infinite recursion.\\n    max_depth = 5\\n    # Holds the selects defined by a call to values() or values_list()\\n    # excluding annotation_select and extra_select.\\n    values_select = ()\\n\\n    # SQL annotation-related attributes.\\n    annotation_select_mask = None\\n    _annotation_select_cache = None\\n\\n    # Set combination attributes.\\n    combinator = None\\n    combinator_all = False\\n    combined_queries = ()\\n\\n    # These are for extensions. The contents are more or less appended verbatim\\n    # to the appropriate clause.\\n    extra_select_mask = None\\n    _extra_select_cache = None\\n\\n    extra_tables = ()\\n    extra_order_by = ()\\n\\n    # A tuple that is a set of model field names and either True, if these are\\n    # the fields to defer, or False if these are the only fields to load.\\n    deferred_loading = (frozenset(), True)\\n\\n    explain_info = None\\n\\n    def __init__(self, model, alias_cols=True):\\n        self.model = model\\n        self.alias_refcount = {}\\n        # alias_map is the most important data structure regarding joins.\\n        # It\\",
          "lines_count": 643
        },
        {
          "file_path": "django/db/models/query.py",
          "start_line": 287,
          "end_line": 287,
          "content": "class QuerySet:\\n",
          "lines_count": 1
        },
        {
          "file_path": "django/db/models/query.py",
          "start_line": 2268,
          "end_line": 2268,
          "content": "                        obj._prefetched_objects_cache = {}\\n",
          "lines_count": 1
        },
        {
          "file_path": "django/db/models/query.py",
          "start_line": 2534,
          "end_line": 2534,
          "content": "class RelatedPopulator:\\n",
          "lines_count": 1
        },
        {
          "file_path": "django/db/models/sql/query.py",
          "start_line": 158,
          "end_line": 158,
          "content": "class Query(BaseExpression):\\n",
          "lines_count": 1
        },
        {
          "file_path": "django/db/models/query.py",
          "start_line": 287,
          "end_line": 1972,
          "content": "class QuerySet:\\n    \"\"\"Represent a lazy database lookup for a set of objects.\"\"\"\\n\\n    def __init__(self, model=None, query=None, using=None, hints=None):\\n        self.model = model\\n        self._db = using\\n        self._hints = hints or {}\\n        self._query = query or sql.Query(self.model)\\n        self._result_cache = None\\n        self._sticky_filter = False\\n        self._for_write = False\\n        self._prefetch_related_lookups = ()\\n        self._prefetch_done = False\\n        self._known_related_objects = {}  # {rel_field: {pk: rel_obj}}\\n        self._iterable_class = ModelIterable\\n        self._fields = None\\n        self._defer_next_filter = False\\n        self._deferred_filter = None\\n\\n    @property\\n    def query(self):\\n        if self._deferred_filter:\\n            negate, args, kwargs = self._deferred_filter\\n            self._filter_or_exclude_inplace(negate, args, kwargs)\\n            self._deferred_filter = None\\n        return self._query\\n\\n    @query.setter\\n    def query(self, value):\\n        if value.values_select:\\n            self._iterable_class = ValuesIterable\\n        self._query = value\\n\\n    def as_manager(cls):\\n        # Address the circular dependency between `Queryset` and `Manager`.\\n        from django.db.models.manager import Manager\\n\\n        manager = Manager.from_queryset(cls)()\\n        manager._built_with_as_manager = True\\n        return manager\\n\\n    as_manager.queryset_only = True\\n    as_manager = classmethod(as_manager)\\n\\n    ########################\\n    # PYTHON MAGIC METHODS #\\n    ########################\\n\\n    def __deepcopy__(self, memo):\\n        \"\"\"Don\\",
          "lines_count": 1686
        },
        {
          "file_path": "django/db/models/query.py",
          "start_line": 2534,
          "end_line": 2617,
          "content": "class RelatedPopulator:\\n    \"\"\"\\n    RelatedPopulator is used for select_related() object instantiation.\\n\\n    The idea is that each select_related() model will be populated by a\\n    different RelatedPopulator instance. The RelatedPopulator instances get\\n    klass_info and select (computed in SQLCompiler) plus the used db as\\n    input for initialization. That data is used to compute which columns\\n    to use, how to instantiate the model, and how to populate the links\\n    between the objects.\\n\\n    The actual creation of the objects is done in populate() method. This\\n    method gets row and from_obj as input and populates the select_related()\\n    model instance.\\n    \"\"\"\\n\\n    def __init__(self, klass_info, select, db):\\n        self.db = db\\n        # Pre-compute needed attributes. The attributes are:\\n        #  - model_cls: the possibly deferred model class to instantiate\\n        #  - either:\\n        #    - cols_start, cols_end: usually the columns in the row are\\n        #      in the same order model_cls.__init__ expects them, so we\\n        #      can instantiate by model_cls(*row[cols_start:cols_end])\\n        #    - reorder_for_init: When select_related descends to a child\\n        #      class, then we want to reuse the already selected parent\\n        #      data. However, in this case the parent data isn\\",
          "lines_count": 84
        },
        {
          "file_path": "django/db/models/sql/query.py",
          "start_line": 158,
          "end_line": 800,
          "content": "class Query(BaseExpression):\\n    \"\"\"A single SQL query.\"\"\"\\n\\n    alias_prefix = \"T\"\\n    empty_result_set_value = None\\n    subq_aliases = frozenset([alias_prefix])\\n\\n    compiler = \"SQLCompiler\"\\n\\n    base_table_class = BaseTable\\n    join_class = Join\\n\\n    default_cols = True\\n    default_ordering = True\\n    standard_ordering = True\\n\\n    filter_is_sticky = False\\n    subquery = False\\n\\n    # SQL-related attributes.\\n    # Select and related select clauses are expressions to use in the SELECT\\n    # clause of the query. The select is used for cases where we want to set up\\n    # the select clause to contain other than default fields (values(),\\n    # subqueries...). Note that annotations go to annotations dictionary.\\n    select = ()\\n    # The group_by attribute can have one of the following forms:\\n    #  - None: no group by at all in the query\\n    #  - A tuple of expressions: group by (at least) those expressions.\\n    #    String refs are also allowed for now.\\n    #  - True: group by all select fields of the model\\n    # See compiler.get_group_by() for details.\\n    group_by = None\\n    order_by = ()\\n    low_mark = 0  # Used for offset/limit.\\n    high_mark = None  # Used for offset/limit.\\n    distinct = False\\n    distinct_fields = ()\\n    select_for_update = False\\n    select_for_update_nowait = False\\n    select_for_update_skip_locked = False\\n    select_for_update_of = ()\\n    select_for_no_key_update = False\\n    select_related = False\\n    # Arbitrary limit for select_related to prevents infinite recursion.\\n    max_depth = 5\\n    # Holds the selects defined by a call to values() or values_list()\\n    # excluding annotation_select and extra_select.\\n    values_select = ()\\n\\n    # SQL annotation-related attributes.\\n    annotation_select_mask = None\\n    _annotation_select_cache = None\\n\\n    # Set combination attributes.\\n    combinator = None\\n    combinator_all = False\\n    combined_queries = ()\\n\\n    # These are for extensions. The contents are more or less appended verbatim\\n    # to the appropriate clause.\\n    extra_select_mask = None\\n    _extra_select_cache = None\\n\\n    extra_tables = ()\\n    extra_order_by = ()\\n\\n    # A tuple that is a set of model field names and either True, if these are\\n    # the fields to defer, or False if these are the only fields to load.\\n    deferred_loading = (frozenset(), True)\\n\\n    explain_info = None\\n\\n    def __init__(self, model, alias_cols=True):\\n        self.model = model\\n        self.alias_refcount = {}\\n        # alias_map is the most important data structure regarding joins.\\n        # It\\",
          "lines_count": 643
        }
      ],
      "test_results": {
        "overall_success": false,
        "issue_resolved": false
      },
      "gold_patch_analysis": {
        "modified_files": [
          "django/db/models/sql/query.py"
        ],
        "context_files": [
          "tests/auth_tests/models/proxy.py",
          "tests/select_related_onetoone/tests.py",
          "tests/proxy_models/tests.py",
          "django/db/models/query.py",
          "tests/auth_tests/test_models.py",
          "tests/defer/tests.py",
          "django/db/models/sql/query.py"
        ],
        "file_coverage": 1.0,
        "covered_files": [
          "django/db/models/sql/query.py"
        ],
        "missed_files": [],
        "total_code_blocks": 1,
        "covered_code_blocks": 1,
        "code_block_coverage": 1.0,
        "code_blocks_detail": [
          {
            "file_path": "django/db/models/sql/query.py",
            "old_start_line": 748,
            "new_start_line": 748,
            "hunk_content": "                     cur_model = source.related_model\n                 else:\n                     cur_model = source.remote_field.model\n+                cur_model = cur_model._meta.concrete_model\n                 opts = cur_model._meta\n                 # Even if we're \"just passing through\" this model, we must add\n                 # both the current model's pk and the related reference field\n",
            "added_lines": [
              "+                cur_model = cur_model._meta.concrete_model"
            ],
            "removed_lines": [],
            "new_end_line": 755,
            "enclosing_functions": [],
            "enclosing_classes": []
          }
        ],
        "function_coverage": {
          "total_functions": 0,
          "covered_functions": 0,
          "coverage_rate": 0,
          "patch_functions": [],
          "context_functions": [
            {
              "name": "test_create_user",
              "line": 516,
              "type": "function",
              "file": "tests/auth_tests/test_models.py"
            },
            {
              "name": "test_create_superuser",
              "line": 520,
              "type": "function",
              "file": "tests/auth_tests/test_models.py"
            },
            {
              "name": "test_create_user",
              "line": 516,
              "type": "function",
              "file": "tests/auth_tests/test_models.py"
            },
            {
              "name": "test_create_superuser",
              "line": 520,
              "type": "function",
              "file": "tests/auth_tests/test_models.py"
            },
            {
              "name": "test_create_user",
              "line": 516,
              "type": "function",
              "file": "tests/auth_tests/test_models.py"
            },
            {
              "name": "test_create_superuser",
              "line": 520,
              "type": "function",
              "file": "tests/auth_tests/test_models.py"
            },
            {
              "name": "test_select_related",
              "line": 313,
              "type": "function",
              "file": "tests/proxy_models/tests.py"
            },
            {
              "name": "test_create_user",
              "line": 516,
              "type": "function",
              "file": "tests/auth_tests/test_models.py"
            },
            {
              "name": "test_create_superuser",
              "line": 520,
              "type": "function",
              "file": "tests/auth_tests/test_models.py"
            },
            {
              "name": "test_select_related",
              "line": 313,
              "type": "function",
              "file": "tests/proxy_models/tests.py"
            },
            {
              "name": "test_only_with_select_related",
              "line": 126,
              "type": "function",
              "file": "tests/defer/tests.py"
            },
            {
              "name": "test_create_user",
              "line": 516,
              "type": "function",
              "file": "tests/auth_tests/test_models.py"
            },
            {
              "name": "test_create_superuser",
              "line": 520,
              "type": "function",
              "file": "tests/auth_tests/test_models.py"
            },
            {
              "name": "test_select_related",
              "line": 313,
              "type": "function",
              "file": "tests/proxy_models/tests.py"
            },
            {
              "name": "test_only_with_select_related",
              "line": 126,
              "type": "function",
              "file": "tests/defer/tests.py"
            }
          ]
        },
        "class_coverage": {
          "total_classes": 0,
          "covered_classes": 0,
          "coverage_rate": 0,
          "patch_classes": [],
          "context_classes": [
            {
              "name": "Concrete",
              "line": 5,
              "type": "class",
              "file": "tests/auth_tests/models/proxy.py"
            },
            {
              "name": "Concrete",
              "line": 5,
              "type": "class",
              "file": "tests/auth_tests/models/proxy.py"
            },
            {
              "name": "ReverseSelectRelatedTestCase",
              "line": 24,
              "type": "class",
              "file": "tests/select_related_onetoone/tests.py"
            },
            {
              "name": "Concrete",
              "line": 5,
              "type": "class",
              "file": "tests/auth_tests/models/proxy.py"
            },
            {
              "name": "ReverseSelectRelatedTestCase",
              "line": 24,
              "type": "class",
              "file": "tests/select_related_onetoone/tests.py"
            },
            {
              "name": "Concrete",
              "line": 5,
              "type": "class",
              "file": "tests/auth_tests/models/proxy.py"
            },
            {
              "name": "ReverseSelectRelatedTestCase",
              "line": 24,
              "type": "class",
              "file": "tests/select_related_onetoone/tests.py"
            },
            {
              "name": "Concrete",
              "line": 5,
              "type": "class",
              "file": "tests/auth_tests/models/proxy.py"
            },
            {
              "name": "ReverseSelectRelatedTestCase",
              "line": 24,
              "type": "class",
              "file": "tests/select_related_onetoone/tests.py"
            },
            {
              "name": "QuerySet",
              "line": 287,
              "type": "class",
              "file": "django/db/models/query.py"
            },
            {
              "name": "RelatedPopulator",
              "line": 2534,
              "type": "class",
              "file": "django/db/models/query.py"
            },
            {
              "name": "Query",
              "line": 158,
              "type": "class",
              "file": "django/db/models/sql/query.py"
            },
            {
              "name": "QuerySet",
              "line": 287,
              "type": "class",
              "file": "django/db/models/query.py"
            },
            {
              "name": "RelatedPopulator",
              "line": 2534,
              "type": "class",
              "file": "django/db/models/query.py"
            },
            {
              "name": "Query",
              "line": 158,
              "type": "class",
              "file": "django/db/models/sql/query.py"
            },
            {
              "name": "QuerySet",
              "line": 287,
              "type": "class",
              "file": "django/db/models/query.py"
            },
            {
              "name": "RelatedPopulator",
              "line": 2534,
              "type": "class",
              "file": "django/db/models/query.py"
            },
            {
              "name": "Query",
              "line": 158,
              "type": "class",
              "file": "django/db/models/sql/query.py"
            },
            {
              "name": "QuerySet",
              "line": 287,
              "type": "class",
              "file": "django/db/models/query.py"
            },
            {
              "name": "RelatedPopulator",
              "line": 2534,
              "type": "class",
              "file": "django/db/models/query.py"
            },
            {
              "name": "Query",
              "line": 158,
              "type": "class",
              "file": "django/db/models/sql/query.py"
            },
            {
              "name": "QuerySet",
              "line": 287,
              "type": "class",
              "file": "django/db/models/query.py"
            },
            {
              "name": "RelatedPopulator",
              "line": 2534,
              "type": "class",
              "file": "django/db/models/query.py"
            },
            {
              "name": "Query",
              "line": 158,
              "type": "class",
              "file": "django/db/models/sql/query.py"
            }
          ]
        }
      }
    },
    {
      "instance_id": "pytest-dev__pytest-8906",
      "project": "pytest-dev",
      "total_contexts_found": 16,
      "unique_files_accessed": 4,
      "contexts_detail": [
        {
          "file_path": "testing/test_skipping.py",
          "start_line": 1348,
          "end_line": 1360,
          "content": "def test_module_level_skip_with_allow_module_level(pytester: Pytester) -> None:\\n    \"\"\"Verify that using pytest.skip(allow_module_level=True) is allowed.\"\"\"\\n    pytester.makepyfile(\\n        \"\"\"\\n        import pytest\\n        pytest.skip(\"skip_module_level\", allow_module_level=True)\\n\\n        def test_func():\\n            assert 0\\n    \"\"\"\\n    )\\n    result = pytester.runpytest(\"-rxs\")\\n    result.stdout.fnmatch_lines([\"*SKIP*skip_module_level\"])\\n",
          "lines_count": 13
        },
        {
          "file_path": "testing/test_skipping.py",
          "start_line": 885,
          "end_line": 896,
          "content": "class TestSkipif:\\n    def test_skipif_conditional(self, pytester: Pytester) -> None:\\n        item = pytester.getitem(\\n            \"\"\"\\n            import pytest\\n            @pytest.mark.skipif(\"hasattr(os, \\",
          "lines_count": 12
        },
        {
          "file_path": "testing/test_skipping.py",
          "start_line": 915,
          "end_line": 924,
          "content": "    def test_skipif_using_platform(self, pytester: Pytester) -> None:\\n        item = pytester.getitem(\\n            \"\"\"\\n            import pytest\\n            @pytest.mark.skipif(\"platform.platform() == platform.platform()\")\\n            def test_func():\\n                pass\\n        \"\"\"\\n        )\\n        pytest.raises(pytest.skip.Exception, lambda: pytest_runtest_setup(item))\\n",
          "lines_count": 10
        },
        {
          "file_path": "testing/test_skipping.py",
          "start_line": 1348,
          "end_line": 1360,
          "content": "def test_module_level_skip_with_allow_module_level(pytester: Pytester) -> None:\\n    \"\"\"Verify that using pytest.skip(allow_module_level=True) is allowed.\"\"\"\\n    pytester.makepyfile(\\n        \"\"\"\\n        import pytest\\n        pytest.skip(\"skip_module_level\", allow_module_level=True)\\n\\n        def test_func():\\n            assert 0\\n    \"\"\"\\n    )\\n    result = pytester.runpytest(\"-rxs\")\\n    result.stdout.fnmatch_lines([\"*SKIP*skip_module_level\"])\\n",
          "lines_count": 13
        },
        {
          "file_path": "testing/test_skipping.py",
          "start_line": 885,
          "end_line": 896,
          "content": "class TestSkipif:\\n    def test_skipif_conditional(self, pytester: Pytester) -> None:\\n        item = pytester.getitem(\\n            \"\"\"\\n            import pytest\\n            @pytest.mark.skipif(\"hasattr(os, \\",
          "lines_count": 12
        },
        {
          "file_path": "testing/test_skipping.py",
          "start_line": 915,
          "end_line": 924,
          "content": "    def test_skipif_using_platform(self, pytester: Pytester) -> None:\\n        item = pytester.getitem(\\n            \"\"\"\\n            import pytest\\n            @pytest.mark.skipif(\"platform.platform() == platform.platform()\")\\n            def test_func():\\n                pass\\n        \"\"\"\\n        )\\n        pytest.raises(pytest.skip.Exception, lambda: pytest_runtest_setup(item))\\n",
          "lines_count": 10
        },
        {
          "file_path": "src/_pytest/outcomes.py",
          "start_line": 124,
          "end_line": 144,
          "content": "def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\\n    \"\"\"Skip an executing test with the given message.\\n\\n    This function should be called only during testing (setup, call or teardown) or\\n    during collection by using the ``allow_module_level`` flag.  This function can\\n    be called in doctests as well.\\n\\n    :param bool allow_module_level:\\n        Allows this function to be called at module level, skipping the rest\\n        of the module. Defaults to False.\\n\\n    .. note::\\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\\n        possible to declare a test to be skipped under certain conditions\\n        like mismatching platforms or dependencies.\\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\\n        to skip a doctest statically.\\n    \"\"\"\\n    __tracebackhide__ = True\\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\\n",
          "lines_count": 21
        },
        {
          "file_path": "src/_pytest/outcomes.py",
          "start_line": 51,
          "end_line": 68,
          "content": "class Skipped(OutcomeException):\\n    # XXX hackish: on 3k we fake to live in the builtins\\n    # in order to have Skipped exception printing shorter/nicer\\n    __module__ = \"builtins\"\\n\\n    def __init__(\\n        self,\\n        msg: Optional[str] = None,\\n        pytrace: bool = True,\\n        allow_module_level: bool = False,\\n        *,\\n        _use_item_location: bool = False,\\n    ) -> None:\\n        OutcomeException.__init__(self, msg=msg, pytrace=pytrace)\\n        self.allow_module_level = allow_module_level\\n        # If true, the skip location is reported as the item\\",
          "lines_count": 18
        },
        {
          "file_path": "src/_pytest/outcomes.py",
          "start_line": 124,
          "end_line": 144,
          "content": "def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\\n    \"\"\"Skip an executing test with the given message.\\n\\n    This function should be called only during testing (setup, call or teardown) or\\n    during collection by using the ``allow_module_level`` flag.  This function can\\n    be called in doctests as well.\\n\\n    :param bool allow_module_level:\\n        Allows this function to be called at module level, skipping the rest\\n        of the module. Defaults to False.\\n\\n    .. note::\\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\\n        possible to declare a test to be skipped under certain conditions\\n        like mismatching platforms or dependencies.\\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\\n        to skip a doctest statically.\\n    \"\"\"\\n    __tracebackhide__ = True\\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\\n",
          "lines_count": 21
        },
        {
          "file_path": "src/_pytest/outcomes.py",
          "start_line": 51,
          "end_line": 68,
          "content": "class Skipped(OutcomeException):\\n    # XXX hackish: on 3k we fake to live in the builtins\\n    # in order to have Skipped exception printing shorter/nicer\\n    __module__ = \"builtins\"\\n\\n    def __init__(\\n        self,\\n        msg: Optional[str] = None,\\n        pytrace: bool = True,\\n        allow_module_level: bool = False,\\n        *,\\n        _use_item_location: bool = False,\\n    ) -> None:\\n        OutcomeException.__init__(self, msg=msg, pytrace=pytrace)\\n        self.allow_module_level = allow_module_level\\n        # If true, the skip location is reported as the item\\",
          "lines_count": 18
        },
        {
          "file_path": "src/_pytest/skipping.py",
          "start_line": 167,
          "end_line": 192,
          "content": "def evaluate_skip_marks(item: Item) -> Optional[Skip]:\\n    \"\"\"Evaluate skip and skipif marks on item, returning Skip if triggered.\"\"\"\\n    for mark in item.iter_markers(name=\"skipif\"):\\n        if \"condition\" not in mark.kwargs:\\n            conditions = mark.args\\n        else:\\n            conditions = (mark.kwargs[\"condition\"],)\\n\\n        # Unconditional.\\n        if not conditions:\\n            reason = mark.kwargs.get(\"reason\", \"\")\\n            return Skip(reason)\\n\\n        # If any of the conditions are true.\\n        for condition in conditions:\\n            result, reason = evaluate_condition(item, mark, condition)\\n            if result:\\n                return Skip(reason)\\n\\n    for mark in item.iter_markers(name=\"skip\"):\\n        try:\\n            return Skip(*mark.args, **mark.kwargs)\\n        except TypeError as e:\\n            raise TypeError(str(e) + \" - maybe you meant pytest.mark.skipif?\") from None\\n\\n    return None\\n",
          "lines_count": 26
        },
        {
          "file_path": "CONTRIBUTING.rst",
          "start_line": 40,
          "end_line": 143,
          "content": "* Detailed steps to reproduce the bug.\\n\\nIf you can write a demonstration test that currently fails but should pass\\n(xfail), that is a very useful commit to make as well, even if you cannot\\nfix the bug itself.\\n\\n\\n.. _fixbugs:\\n\\nFix bugs\\n--------\\n\\nLook through the `GitHub issues for bugs <https://github.com/pytest-dev/pytest/labels/type:%20bug>`_.\\n\\n:ref:`Talk <contact>` to developers to find out how you can fix specific bugs. To indicate that you are going\\nto work on a particular issue, add a comment to that effect on the specific issue.\\n\\nDon\\",
          "lines_count": 104
        },
        {
          "file_path": "src/_pytest/outcomes.py",
          "start_line": 124,
          "end_line": 144,
          "content": "def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\\n    \"\"\"Skip an executing test with the given message.\\n\\n    This function should be called only during testing (setup, call or teardown) or\\n    during collection by using the ``allow_module_level`` flag.  This function can\\n    be called in doctests as well.\\n\\n    :param bool allow_module_level:\\n        Allows this function to be called at module level, skipping the rest\\n        of the module. Defaults to False.\\n\\n    .. note::\\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\\n        possible to declare a test to be skipped under certain conditions\\n        like mismatching platforms or dependencies.\\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\\n        to skip a doctest statically.\\n    \"\"\"\\n    __tracebackhide__ = True\\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\\n",
          "lines_count": 21
        },
        {
          "file_path": "src/_pytest/outcomes.py",
          "start_line": 51,
          "end_line": 68,
          "content": "class Skipped(OutcomeException):\\n    # XXX hackish: on 3k we fake to live in the builtins\\n    # in order to have Skipped exception printing shorter/nicer\\n    __module__ = \"builtins\"\\n\\n    def __init__(\\n        self,\\n        msg: Optional[str] = None,\\n        pytrace: bool = True,\\n        allow_module_level: bool = False,\\n        *,\\n        _use_item_location: bool = False,\\n    ) -> None:\\n        OutcomeException.__init__(self, msg=msg, pytrace=pytrace)\\n        self.allow_module_level = allow_module_level\\n        # If true, the skip location is reported as the item\\",
          "lines_count": 18
        },
        {
          "file_path": "src/_pytest/skipping.py",
          "start_line": 167,
          "end_line": 192,
          "content": "def evaluate_skip_marks(item: Item) -> Optional[Skip]:\\n    \"\"\"Evaluate skip and skipif marks on item, returning Skip if triggered.\"\"\"\\n    for mark in item.iter_markers(name=\"skipif\"):\\n        if \"condition\" not in mark.kwargs:\\n            conditions = mark.args\\n        else:\\n            conditions = (mark.kwargs[\"condition\"],)\\n\\n        # Unconditional.\\n        if not conditions:\\n            reason = mark.kwargs.get(\"reason\", \"\")\\n            return Skip(reason)\\n\\n        # If any of the conditions are true.\\n        for condition in conditions:\\n            result, reason = evaluate_condition(item, mark, condition)\\n            if result:\\n                return Skip(reason)\\n\\n    for mark in item.iter_markers(name=\"skip\"):\\n        try:\\n            return Skip(*mark.args, **mark.kwargs)\\n        except TypeError as e:\\n            raise TypeError(str(e) + \" - maybe you meant pytest.mark.skipif?\") from None\\n\\n    return None\\n",
          "lines_count": 26
        },
        {
          "file_path": "CONTRIBUTING.rst",
          "start_line": 40,
          "end_line": 143,
          "content": "* Detailed steps to reproduce the bug.\\n\\nIf you can write a demonstration test that currently fails but should pass\\n(xfail), that is a very useful commit to make as well, even if you cannot\\nfix the bug itself.\\n\\n\\n.. _fixbugs:\\n\\nFix bugs\\n--------\\n\\nLook through the `GitHub issues for bugs <https://github.com/pytest-dev/pytest/labels/type:%20bug>`_.\\n\\n:ref:`Talk <contact>` to developers to find out how you can fix specific bugs. To indicate that you are going\\nto work on a particular issue, add a comment to that effect on the specific issue.\\n\\nDon\\",
          "lines_count": 104
        }
      ],
      "test_results": {
        "overall_success": false,
        "issue_resolved": false
      },
      "gold_patch_analysis": {
        "modified_files": [
          "src/_pytest/python.py"
        ],
        "context_files": [
          "src/_pytest/outcomes.py",
          "testing/test_skipping.py",
          "CONTRIBUTING.rst",
          "src/_pytest/skipping.py"
        ],
        "file_coverage": 0.0,
        "covered_files": [],
        "missed_files": [
          "src/_pytest/python.py"
        ],
        "total_code_blocks": 1,
        "covered_code_blocks": 0,
        "code_block_coverage": 0.0,
        "code_blocks_detail": [
          {
            "file_path": "src/_pytest/python.py",
            "old_start_line": 608,
            "new_start_line": 608,
            "hunk_content": "             if e.allow_module_level:\n                 raise\n             raise self.CollectError(\n-                \"Using pytest.skip outside of a test is not allowed. \"\n-                \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"Using pytest.skip outside of a test will skip the entire module. \"\n+                \"If that's your intention, pass `allow_module_level=True`. \"\n+                \"If you want to skip a specific test or an entire class, \"\n+                \"use the @pytest.mark.skip or @pytest.mark.skipif decorators.\"\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\n",
            "added_lines": [
              "+                \"Using pytest.skip outside of a test will skip the entire module. \"",
              "+                \"If that's your intention, pass `allow_module_level=True`. \"",
              "+                \"If you want to skip a specific test or an entire class, \"",
              "+                \"use the @pytest.mark.skip or @pytest.mark.skipif decorators.\""
            ],
            "removed_lines": [
              "-                \"Using pytest.skip outside of a test is not allowed. \"",
              "-                \"To decorate a test function, use the @pytest.mark.skip \"",
              "-                \"or @pytest.mark.skipif decorators instead, and to skip a \"",
              "-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\""
            ],
            "new_end_line": 618,
            "enclosing_functions": [],
            "enclosing_classes": []
          }
        ],
        "function_coverage": {
          "total_functions": 0,
          "covered_functions": 0,
          "coverage_rate": 0,
          "patch_functions": [],
          "context_functions": [
            {
              "name": "test_module_level_skip_with_allow_module_level",
              "line": 1348,
              "type": "function",
              "file": "testing/test_skipping.py"
            },
            {
              "name": "test_skipif_using_platform",
              "line": 915,
              "type": "function",
              "file": "testing/test_skipping.py"
            },
            {
              "name": "test_module_level_skip_with_allow_module_level",
              "line": 1348,
              "type": "function",
              "file": "testing/test_skipping.py"
            },
            {
              "name": "test_skipif_using_platform",
              "line": 915,
              "type": "function",
              "file": "testing/test_skipping.py"
            },
            {
              "name": "skip",
              "line": 124,
              "type": "function",
              "file": "src/_pytest/outcomes.py"
            },
            {
              "name": "skip",
              "line": 124,
              "type": "function",
              "file": "src/_pytest/outcomes.py"
            },
            {
              "name": "evaluate_skip_marks",
              "line": 167,
              "type": "function",
              "file": "src/_pytest/skipping.py"
            },
            {
              "name": "skip",
              "line": 124,
              "type": "function",
              "file": "src/_pytest/outcomes.py"
            },
            {
              "name": "evaluate_skip_marks",
              "line": 167,
              "type": "function",
              "file": "src/_pytest/skipping.py"
            }
          ]
        },
        "class_coverage": {
          "total_classes": 0,
          "covered_classes": 0,
          "coverage_rate": 0,
          "patch_classes": [],
          "context_classes": [
            {
              "name": "TestSkipif",
              "line": 885,
              "type": "class",
              "file": "testing/test_skipping.py"
            },
            {
              "name": "TestSkipif",
              "line": 885,
              "type": "class",
              "file": "testing/test_skipping.py"
            },
            {
              "name": "Skipped",
              "line": 51,
              "type": "class",
              "file": "src/_pytest/outcomes.py"
            },
            {
              "name": "Skipped",
              "line": 51,
              "type": "class",
              "file": "src/_pytest/outcomes.py"
            },
            {
              "name": "Skipped",
              "line": 51,
              "type": "class",
              "file": "src/_pytest/outcomes.py"
            }
          ]
        }
      }
    }
  ],
  "last_updated": "2025-08-11 13:05:28"
}